\chapter{Iterators}

\index{Iterator!Concept}
\index{Generic Programming}
This chapter introduces the \emph{image iterator}, a fundamental and important
generic programming construct for image processing in ITK.  An iterator is a
generalization of the familiar C pointer and is used to access data in memory.  ITK
has a wide variety of iterators, some of which are highly specialized to
simplify common image processing tasks.

The section that follows is a brief introduction that defines iterators in the
context of ITK and the \code{itk::Image} and describes their common programming
interface.  The specific types and instances of iterators are documented in the
last sections of this chapter, along with some examples of how they can be
used.

\section{Overview}
\label{sec:IteratorsIntroduction}
% Further define iterators in the context of generic programming.
Generic programming models define functionally independent components called
\emph{containers} and \emph{algorithms}.  Algorithms operate on data
within containers.  Iterators keep these two components independent of one
another by presenting the algorithm object with a generic interface for
fetching and storing data in any container object type.  Using iterators,
algorithm code can be written that does not depend on one specific
representation of data.

The iterator gets its name because it is designed for \emph{iterative},
sequential access of container values.  The typical use of an iterator is to
visit each data point in a container to apply an operation or calculate a
value.  A C pointer, for example, is a type of iterator.  It can be pointed at
a beginning location in a memory array and then iteratively incremented until
reaching the end of that array.  Most iterator implementations, in fact, have
an interface which looks somewhat like that of the C pointer.

% Define iterators in the context of ITK generic programming. 
In ITK, we use iterators to write image processing code that can be
instantiated and run on \code{itk::Image}s of any combination of pixel type,
pixel container type, and dimensionality (see itk::Image).
Figure~\ref{fig:ImageIterators} illustrates how image iterators are the glue
between ITK filters (algorithms) and different ITK image types (data
containers). A filter processes data in an image one pixel at a time.  The
\emph{iterator} is incremented at each \emph{iteration} of the inner processing
loop.

\begin{figure}
\centering
%\includegraphics[width=0.9\textwidth]{}
%figure with small graphic illustrating algorithm & iterators plus some simple pseudocode.
\caption[Image iterators in ITK]{Image iterators in ITK}
\protect\label{fig:ImageIterators}
\end{figure}

% List advantages: code size/reuse. increased performance over set/get in image, allow to ignore
% dimensionality. 
There are many advantages to using ITK image iterators over direct pixel access
through \code{itk::Image::Set} and \code{itk::Image::Get} methods.  Code is
more compact and often generalizes automatically to higher dimensions,
algorithms run much faster, and iterators simplify tasks such as
multithreading, neighborhood image processing, and working with non-rectilinear
regions of interest.  These advantages are illustrated in the sections to
follow.

%Image iterators can encapsulate much of the complexity of writing many common
%algorithms.  Some ITK iterators, for example, have been designed to walk
%non-rectilinear paths through an image, allowing specialized processing over
%regions of interest or boundary pixels.  Other iterators efficiently manage
%access to entire N-dimensional neighborhoods, making localized image processing
%algorithms simple to write and to generalize to higher dimensions.

% Creating iterators
Whenever possible, ITK iterators share a common interface.  Iterators are
initialized by passing an \code{itk::Image} smart pointer and region to the
constructor.  The region defines the rectilinear hypervolume that the iterator
will walk within the image.  

To set up for iteration through a region, the iterator must be positioned at a
starting location by one of two methods.

\begin{itemize}
\item \textbf{\code{GoToBegin()}} points the iterator to the first valid
data element in the region.

\item \textbf{\code{GoToEnd()}} points the iterator to \emph{one position past}
the last valid element in the region.
\end{itemize}

%Moving iteators
ITK iterators define forward and reverse movement through their regions by
overloading the increment and decrement operators.

\begin{itemize}
\item \textbf{\code{operator++()}} Increments the iterator one position in the
positive direction.

\item \textbf{\code{operator--()}} Decrements the iterator one position in the
negative direction.  Not all ITK iterators define this method.
\end{itemize}

Most iterators, will increment and decrement in the direction of the fastest
increasing image dimension, wrapping around region boundaries.  As illustrated
in figure~{\ref{fig:WalkingIterator}}, a typical iterator moves across columns
and down rows.  When it reaches the end of the last row in the first slice, the
iterator wraps to the beginning of the first row in the next slice.  Some
iterators do not follow a predetermined path through their regions.  A
conditional iterator (section~\ref{sec:ConditionalIterators}), for example,
visits pixels only if they have certain values or connectivities.  Random
iterators, as their name implies, increment and decrement to random locations,
and may visit a pixel more than once.

\begin{figure}
\centering
%\includegraphics[width=0.9\textwidth]{}
%figure with small graphic illustrating algorithm & iterators plus some simple pseudocode.
\caption[Normal iterator path.]{Normal path of an iterator through an image}
\protect\label{fig:WalkingIterator}
\end{figure}


%Testing for location
\begin{itemize}
\item \textbf{\code{IsAtEnd()}} 
\item \textbf{\code{IsAtBegin()}}
\end{itemize}


%Accessing data.
\begin{itemize}
\item \textbf{\code{Get()}}
\item \textbf{\code{Set()}}
\end{itemize}

% Describe efficiency due to inlining for all cases
%The use of Set, Get also supports image adaptors (section reference?)
% segue to the case where you need the Value method

\begin{itemize}
\item \textbf{\code{Value()}}
\end{itemize}

% Now give a psuedo code example for putting all of this together.
Using the methods described above, we can now write a simple example for
pixel-wise operations in any image region.  The following code calculates the
square all of the values in an image.

\begin{verbatim}
Iterator it(image, image->GetRequestedRegion());

for (it.GoToBegin(); !it.IsAtEnd(); ++it)
{
  it.Set( it.Get() * it.Get() );
}
\end{verbatim}


\section{Image Iterators}
\label{sec:ImageIterators}
This section describes iterators that walk rectilinear regions in images and
reference a single pixel.


\subsection{itk::ImageRegionIterator}
\label{sec:itkImageRegionIterator}
./Common/itkImageRegionConstIterator.h
./Common/itkImageRegionIterator.h
(./Common/itkImageConstIterator.h base class)
(./Common/itkImageIterator.h base class)
\input{ImageRegionIterator.tex}

%Need to discuss the value method and
%[where traditional iterators overload the * operator, in ITK we have chosen to
%use Set Get]
%        Get
%        Set
%Set methods are only defined in const iterators.
%Some iterators also supply a Value() method to allow dereferencing and modifying a
%pixel value in a single step.  For example: [give example of how if you wanted
%to do something like *it++ you would have to write it as it.Set(it.Get() + 1),
%whereas it.Value()++ saves one dereference]


\begin{itemize}
\item{\textbf{\code{Value()}}}
\end{itemize}



\subsection{itk::ImageRegionIteratorWithIndex}
\label{sec:itkImageRegionIteratorWithIndex}
./Common/itkImageRegionConstIteratorWithIndex.h
./Common/itkImageRegionIteratorWithIndex.h
(./Common/itkImageConstIteratorWithIndex.h  base class )
(./Common/itkImageIteratorWithIndex.h  base class )

\subsection{itk::ImageSliceIteratorWithIndex}
\label{sec:itkImageSliceIteratorWithIndex}
./Common/itkImageSliceConstIteratorWithIndex.
./Common/itkImageSliceIteratorWithIndex.h

\subsection{itk::ImageLinearIteratorWithIndex}
\label{sec:itkImageLinearIteratorWithIndex}
./Common/itkImageLinearConstIteratorWithIndex.h
./Common/itkImageLinearIteratorWithIndex.h

\subsection{itk::ImageRandomConstIteratorWithIndex}
\label{sec:itkImageRandomConstIteratorWithIndex}
./Common/itkImageRandomConstIteratorWithIndex.h
./Common/itkImageRandomIteratorWithIndex.h


\section{Conditional Iterators}
\label{sec:ConditionalIterators}

[Introduction and overview]

./Common/itkConditionalConstIterator.h (BaseClass)
./Common/itkConditionalIterator.h (BaseClass)
./Common/itkFloodFilledFunctionConditionalConstIterator.h (BaseClass)
./Common/itkFloodFilledFunctionConditionalIterator.h (BaseClass)


%[ here are all classes where these filters are used:
% ./BasicFilters/itkConfidenceConnectedImageFilter.txx (ImageFunction)
% ./BasicFilters/itkConnectedThresholdImageFilter.txx (ImageFunction)
% ./BasicFilters/itkIsolatedConnectedImageFilter.txx (ImageFunction)
% ./BasicFilters/itkNeighborhoodConnectedImageFilter.txx (ImageFunction)
%
% ./Common/itkBinaryBallStructuringElement.txx (SpatialFunction)
% ./Common/itkBloxCoreAtomImage.txx (SpatialFunction)
% ./BasicFilters/itkBloxBoundaryPointToCoreAtomImageFilter.txx (SpatialFunction)
% ./BasicFilters/itkBloxBoundaryPointImageToBloxBoundaryProfileImageFilter.txx (SpatialFunction)
%]

\subsection{itk::FloodFilledImageFunctionConditionalIterator}
\label{itk::FloodFilledImageFunctionConditionalIterator}
./Common/itkFloodFilledImageFunctionConditionalConstIterator.h
./Common/itkFloodFilledImageFunctionConditionalIterator.h


\subsection{itk::FloodFilledSpatialFunctionConditionalIterator}
\label{itk::FloodFilledSpatialFunctionConditionalIterator}
./Common/itkFloodFilledSpatialFunctionConditionalConstIterator.h
./Common/itkFloodFilledSpatialFunctionConditionalIterator.h


\section{Neighborhood Iterators}
\label{sec:NeighborhoodIterators}

%Do not support image adaptors

%[Introduction goes here]
%[Be sure to reference Section: Neighborhood Filters]

% Example: derivative
% Example: convolution filtering
% Example: boundary conditions
% Example: walking faces

\subsection{itk::NeighborhoodIterator}
\label{sec:itkNeighborhoodIterator}
./Common/itkConstNeighborhoodIterator.h
./Common/itkNeighborhoodIterator.h

\subsection{itk::ShapedNeighborhoodIterator}
\label{sec:itkShapedNeighborhoodIterator}
./Common/itkConstShapedNeighborhoodIterator.h
./Common/itkShapedNeighborhoodIterator.h






















