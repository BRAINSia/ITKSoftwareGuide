\chapter{Iterators}

\index{Iterator!Concept}
\index{Generic Programming}
This chapter introduces the \emph{image iterator}, a fundamental and important
generic programming construct for image processing in ITK.  An iterator is a
generalization of the familiar C pointer and is used to access data in memory.  ITK
has a wide variety of iterators, some of which are highly specialized to
simplify common image processing tasks.

The section that follows is a brief introduction that defines iterators in the
context of ITK and the \code{itk::Image} and describes their common programming
interface.  The specific types and instances of iterators are documented in the
last sections of this chapter, along with some examples of how they can be
used.

\section{Overview}
\label{sec:IteratorsIntroduction}
% Further define iterators in the context of generic programming.
Generic programming models define functionally independent components called
\emph{containers} and \emph{algorithms}.  Algorithms operate on data
within containers.  Iterators keep these two components independent of one
another by presenting the algorithm object with a generic interface for
fetching and storing data in any container object type.  Using iterators,
algorithm code can be written that does not depend on one specific
representation of data.

The iterator gets its name because it is designed for \emph{iterative},
sequential access of container values.  The typical use of an iterator is to
visit each data point in a container to apply an operation or calculate a
value.  A C pointer, for example, is a type of iterator.  It can be pointed at
a beginning location in a memory array and then iteratively incremented until
reaching the end of that array.  Most iterator implementations, in fact, have
an interface which looks somewhat like that of the C pointer.

% Define iterators in the context of ITK generic programming. 
In ITK, we use iterators to write image processing code that can be
instantiated and run on \code{itk::Image}s of any combination of pixel type,
pixel container type, and dimensionality (see itk::Image).
Figure~\ref{fig:ImageIterators} illustrates how image iterators are the glue
between ITK filters (algorithms) and different ITK image types (data
containers). A filter processes data in an image one pixel at a time.  The
\emph{iterator} is incremented at each \emph{iteration} of the inner processing
loop.  

%ITK image iterators visit grid indicies in images, not spatial locations

\begin{figure}
\centering
%\includegraphics[width=0.9\textwidth]{}
%figure with small graphic illustrating algorithm & iterators plus some simple pseudocode.
\caption[Image iterators in ITK]{Image iterators in ITK}
\protect\label{fig:ImageIterators}
\end{figure}

% List advantages: code size/reuse. increased performance over set/get in image, allow to ignore
% dimensionality. 
There are many advantages to using ITK image iterators over direct pixel access
through \code{itk::Image::Set} and \code{itk::Image::Get} methods.  Code is
more compact and often generalizes automatically to higher dimensions,
algorithms run much faster, and iterators simplify tasks such as
multithreading, neighborhood image processing, and working with non-rectilinear
regions of interest.  These advantages are illustrated in the sections to
follow.

%Image iterators can encapsulate much of the complexity of writing many common
%algorithms.  Some ITK iterators, for example, have been designed to walk
%non-rectilinear paths through an image, allowing specialized processing over
%regions of interest or boundary pixels.  Other iterators efficiently manage
%access to entire N-dimensional neighborhoods, making localized image processing
%algorithms simple to write and to generalize to higher dimensions.

% Creating iterators
% Expand the following into a whole section on the interface?
Whenever possible, ITK iterators share a common interface.  Iterators are
initialized by passing an \code{itk::Image} smart pointer and region to the
constructor.  The region defines the rectilinear hypervolume that the iterator
will walk within the image.  Iteration is confined to the region over which the
iterator was initialized.

To set up for iteration through a region, the iterator must be positioned at a
starting location by one of two methods.

\begin{itemize}
\item \textbf{\code{GoToBegin()}} points the iterator to the first valid
data element in the region.

\item \textbf{\code{GoToEnd()}} points the iterator to \emph{one position past}
the last valid element in the region.
\end{itemize}

%Moving iteators
ITK iterators define forward and reverse movement through their regions by
overloading the increment and decrement operators.

\begin{itemize}
\item \textbf{\code{operator++()}} Increments the iterator one position in the
positive direction.

\item \textbf{\code{operator--()}} Decrements the iterator one position in the
negative direction.  Not all ITK iterators define this method.
\end{itemize}

Most iterators, will increment and decrement in the direction of the fastest
increasing image dimension, wrapping around region boundaries.  As illustrated
in figure~{\ref{fig:WalkingIterator}}, a typical iterator moves across columns
and down rows.  When it reaches the end of the last row in the first slice, the
iterator wraps to the beginning of the first row in the next slice.  Some
iterators do not follow a predetermined path through their regions.  A
conditional iterator (section~\ref{sec:ConditionalIterators}), for example,
visits pixels only if they have certain values or connectivities.  Random
iterators, as their name implies, increment and decrement to random locations,
and may visit a pixel more than once.

\begin{figure}
\centering
%\includegraphics[width=0.9\textwidth]{}
%figure with small graphic illustrating algorithm & iterators plus some simple pseudocode.
\caption[Normal iterator path.]{Normal path of an iterator through an image}
\protect\label{fig:WalkingIterator}
\end{figure}


%Testing for location
An iterator can be queried to determine if it is at the beginning or the end of
its iteration region.  These methods are used as halting criteria for iteration
loops.

\begin{itemize}
\item \textbf{\code{bool IsAtEnd()}} True if the iterator points to \emph{one
position past} the end of the iteration region.

\item \textbf{\code{bool IsAtBegin()}} True if the iterator points to the first
position in the iteration region.  The method is typically used to test for the
end of reverse iteration.
\end{itemize}


%Accessing data.
Two methods are commonly defined for ITK iterators to access data.

\begin{itemize}
\item \textbf{\code{PixelType Get()}} Returns the value of the pixel at the
iterator position.

\item \textbf{\code{void Set( PixelType )}}Sets the value of the pixel at the
iterator position.
\end{itemize}


% Describe efficiency due to inlining for all cases
The \code{Get} and \code{Set} methods are inlined and optimized for speed. For
most cases, calling either of these methods incurs no penalty over directly
dereferencing the memory pointer in the underlying image memory buffer.
\code{Get} and \code{Set} methods also support image adaptors (section~\ref{}).

There is one common case where \code{Get} and \code{Set} do incur a penalty.
The following line of code fetches, modifies, and then writes a value back to
the same pixel location.

\begin{verbatim}
it.Set( it.Get() + 1 );
\end{verbatim}

As written, this code requires one more memory dereference than necessary.  To
handle this case, some iterators define a third method.

\begin{itemize}
\item \textbf{\code{PixelType \& Value()}} Returns a reference to the pixel at
the iterator position.
\end{itemize}

The \code{Value} method can be either an lval or an rval in an expression.  This
makes it possible to rewrite our example code more efficiently.

\begin{verbatim}
it.Value()++;
\end{verbatim}

The \code{Value} method, however, cannot support the use of image adaptors.
Whenever possible, you should use \code{Get} and \code{Set} instead.  Because
ITK filters do not modify the contents of their input images, situations
calling for \code{Value} are less common than might be supposed.  More often
than not, an algorithm operates on two images, an input from which values are
only read (\code{Get}), and an output to which values are only written
(\code{Set}).

% Now give a psuedo code example for putting all of this together.
Using the methods described above, we can now write a simple example for
pixel-wise operations in any image region.  The following code writes the
square all of the values in an input image to an output image using two
iterators.

\begin{verbatim}
ConstIteratorType in(input_image,   input_image->GetRequestedRegion());
IteratorType out(output_image, input_image->GetRequestedRegion());

for (in.GoToBegin(), out.GoToBegin(); !in.IsAtEnd(); ++in, ++out)
{
  out.Set( in.Get() * in.Get() );
}
\end{verbatim}

Notice that both the input and output iterators are initialized over the same
region, that of \code{input\_image}.  This is good practice because it ensures
that the output iterator walks exactly the same set of pixel indicies as the
input iterator, but does not require that the output and input be the same
size.  The only requirement is that the output image must contain the requested
region of the input image.  Another advantage is that only one test for the end
of iteration is required in the \code{for} loop.

The input iterator in the previous example is of \code{const} type.  Most ITK
image iterators have a const and non-const version.  A non-const iterator
cannot be instantiated with a const \code{itk::Image} smart pointer.

% Need a paragraph or two about other image methods like GetIndex(), etc.  Are
%these universally defined?

% SetIndex()

% operator <, operator >, etc.

\section{Image Iterators}
\label{sec:ImageIterators}
%Introduction and overview
This section describes iterators that walk rectilinear regions in images and
reference a single pixel.


\subsection{itk::ImageRegionIterator}
\label{sec:itkImageRegionIterator}
% Table which lists fetatures?
%./Common/itkImageRegionConstIterator.h
%./Common/itkImageRegionIterator.h
%(./Common/itkImageConstIterator.h base class)
%(./Common/itkImageIterator.h base class)
\input{ImageRegionIterator.tex}

The \code{itk::ImageRegionIterator} has been optimized for iteration speed.  It
is the first choice for doing pixelwise operations that do not depend on
location in an image.  Querying for the index of the iterator is still
possible, but incurs a penalty.  For situations where an algorithm needs to
efficiently keep track of the indicies associated with its pixels (GIVE SOME
EXAMPLES?), the itk::ImageRegionIteratorWithIndex() is a better choice.

\subsection{itk::ImageRegionIteratorWithIndex}
\label{sec:itkImageRegionIteratorWithIndex}
%./Common/itkImageRegionConstIteratorWithIndex.h
%./Common/itkImageRegionIteratorWithIndex.h
%(./Common/itkImageConstIteratorWithIndex.h  base class )
%(./Common/itkImageIteratorWithIndex.h  base class )
This iterator was designed for use in situations where querying for the
iterator's index needs to be fast.  Unlike \code{itk::ImageRegionIterator},
which calculates the index only when queried,
\code{itk::ImageRegionIteratorWithIndex} keeps the index as a member variable
which is updated each time the iterator is incremented.  This means there is a
penalty on the iteration speed.

%
% SUGGEST SOME POSSIBLE USES HERE???

\input{ImageRegionIteratorWithIndex.tex}

%\code{Itk::ImageRegionIteratorWithIndex} is a good example of how ITK iterators
%encapsulate common functionality. If an algorithm like the one presented above
%were written by explicitly incrementing an index counter at each iteration, it
%would require simultneous knowledge of the image dimensionality, the image
% size, and the offset betw


\subsection{itk::ImageSliceIteratorWithIndex}
\label{sec:itkImageSliceIteratorWithIndex}
%./Common/itkImageSliceConstIteratorWithIndex.
%./Common/itkImageSliceIteratorWithIndex.h

\subsection{itk::ImageLinearIteratorWithIndex}
\label{sec:itkImageLinearIteratorWithIndex}
%./Common/itkImageLinearConstIteratorWithIndex.h
%./Common/itkImageLinearIteratorWithIndex.h

\subsection{itk::ImageRandomConstIteratorWithIndex}
\label{sec:itkImageRandomConstIteratorWithIndex}
%./Common/itkImageRandomConstIteratorWithIndex.h
%./Common/itkImageRandomIteratorWithIndex.h


\section{Conditional Iterators}
\label{sec:ConditionalIterators}
This section describes iterators that walk only pixels whose values satisfy a
condition.

%./Common/itkConditionalConstIterator.h (BaseClass)
%./Common/itkConditionalIterator.h (BaseClass)
%./Common/itkFloodFilledFunctionConditionalConstIterator.h (BaseClass)
%./Common/itkFloodFilledFunctionConditionalIterator.h (BaseClass)


%[ here are all classes where these filters are used:
% ./BasicFilters/itkConfidenceConnectedImageFilter.txx (ImageFunction)
% ./BasicFilters/itkConnectedThresholdImageFilter.txx (ImageFunction)
% ./BasicFilters/itkIsolatedConnectedImageFilter.txx (ImageFunction)
% ./BasicFilters/itkNeighborhoodConnectedImageFilter.txx (ImageFunction)
%
% ./Common/itkBinaryBallStructuringElement.txx (SpatialFunction)
% ./Common/itkBloxCoreAtomImage.txx (SpatialFunction)
% ./BasicFilters/itkBloxBoundaryPointToCoreAtomImageFilter.txx (SpatialFunction)
% ./BasicFilters/itkBloxBoundaryPointImageToBloxBoundaryProfileImageFilter.txx (SpatialFunction)
%]

\subsection{itk::FloodFilledImageFunctionConditionalIterator}
\label{itk::FloodFilledImageFunctionConditionalIterator}
%./Common/itkFloodFilledImageFunctionConditionalConstIterator.h
%./Common/itkFloodFilledImageFunctionConditionalIterator.h


\subsection{itk::FloodFilledSpatialFunctionConditionalIterator}
\label{itk::FloodFilledSpatialFunctionConditionalIterator}
%./Common/itkFloodFilledSpatialFunctionConditionalConstIterator.h
%./Common/itkFloodFilledSpatialFunctionConditionalIterator.h


\section{Neighborhood Iterators}
\label{sec:NeighborhoodIterators}
This section describes iterators which walk rectilinear regions and reference a
local neighborhood of image pixels.

%Do not support image adaptors

%[Introduction goes here]
%[Be sure to reference Section: Neighborhood Filters]

% Example: derivative
% Example: convolution filtering
% Example: boundary conditions
% Example: walking faces

\subsection{itk::NeighborhoodIterator}
\label{sec:itkNeighborhoodIterator}
./Common/itkConstNeighborhoodIterator.h
./Common/itkNeighborhoodIterator.h

\subsection{itk::ShapedNeighborhoodIterator}
\label{sec:itkShapedNeighborhoodIterator}
./Common/itkConstShapedNeighborhoodIterator.h
./Common/itkShapedNeighborhoodIterator.h


% ADD A SECTION WITH TIPS, SUGGESTIONS ON USING ITERATORS?  EXTENDING ITERATORS?




















