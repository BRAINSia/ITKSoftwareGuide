\chapter{Iterators}

% NOTES: WithIndex... not needed in BSPlineDecomposition, 

% Add pointers to filters which use particular iterator types?  See alsos.

% Need to work in the concept ``multidimensional iterator'' somewhere

% Indexing

\index{Iterator!Concept}
\index{Generic Programming}
This chapter introduces the \emph{image iterator}, a fundamental and important
generic programming construct for image processing in ITK.  An iterator is a
generalization of the familiar C pointer and is used to access data in memory.  ITK
has a wide variety of iterators, some of which are highly specialized to
simplify common image processing tasks.

The section that follows is a brief introduction that defines iterators in the
context of ITK, and describes their common programming
interface.  The specific types and instances of iterators are documented in the
last sections of this chapter, along with some examples of how they can be
used.

\section{Overview}
\label{sec:IteratorsIntroduction}
% Further define iterators in the context of generic programming.
Generic programming models define functionally independent components called
\emph{containers} and \emph{algorithms}.  Algorithms operate on data
within containers.  Iterators keep these two components independent of one
another by presenting the algorithm object with a generic interface for
fetching and storing data in any container object type.  Using iterators,
algorithm code can be written that does not depend on one specific
representation of data.

The iterator gets its name because it is designed for \emph{iterative},
sequential access of container values.  The typical use of an iterator is to
visit each data point in a container to apply an operation or calculate a
value.  A C pointer, for example, is a type of iterator.  It can be pointed at
a beginning location in a memory array and then iteratively incremented until
reaching the end of that array.  Most iterator implementations, in fact, have
an interface which looks somewhat like that of the C pointer.

% Define iterators in the context of ITK generic programming. 
In ITK, we use iterators to write image processing code that can be
instantiated and run on \code{itk::Image}s of any combination of pixel type,
pixel container type, and dimensionality (see itk::Image).
Figure~\ref{fig:ImageIterators} illustrates how image iterators are the glue
between ITK filters (algorithms) and different ITK image types (data
containers). A filter processes data in an image one pixel grid location at a time.  The
\emph{iterator} is incremented at each \emph{iteration} of the inner processing
loop.  


\begin{figure}
\centering
%\includegraphics[width=0.9\textwidth]{}
%figure with small graphic illustrating algorithm & iterators plus some simple pseudocode.
\caption[Image iterators in ITK]{Image iterators in ITK}
\protect\label{fig:ImageIterators}
\end{figure}

% List advantages: code size/reuse. increased performance over set/get in image, allow to ignore
% dimensionality. 
There are many advantages to using ITK image iterators over direct pixel access
through \code{itk::Image::Set} and \code{itk::Image::Get} methods.  Code is
more compact and often generalizes automatically to higher dimensions,
algorithms run much faster, and iterators simplify tasks such as
multithreading, neighborhood image processing, and working with non-rectilinear
regions of interest.  These advantages are illustrated in the sections to
follow.

%Image iterators can encapsulate much of the complexity of writing many common
%algorithms.  Some ITK iterators, for example, have been designed to walk
%non-rectilinear paths through an image, allowing specialized processing over
%regions of interest or boundary pixels.  Other iterators efficiently manage
%access to entire N-dimensional neighborhoods, making localized image processing
%algorithms simple to write and to generalize to higher dimensions.

% Creating iterators
% Expand the following into a whole section on the interface?
Whenever possible, ITK iterators share a common interface.  Iterators are
initialized by passing an \code{itk::Image} smart pointer and region to the
constructor.  The region defines the rectilinear hypervolume that the iterator
will walk within the image.  Iteration will not occur outside of that region.

Before iteration begins, an iterator is positioned at a starting location by
one of two methods.

\begin{itemize}
\item \textbf{\code{GoToBegin()}} Points the iterator to the first valid
data element in the region.

\item \textbf{\code{GoToEnd()}} Points the iterator to \emph{one position past}
the last valid element in the region.
\end{itemize}

%Moving iteators
ITK iterators define forward and reverse movement through their regions by
overloading the increment and decrement operators.

\begin{itemize}
\item \textbf{\code{operator++()}} Increments the iterator one position in the
positive direction.  Only the prefix increment operator is defined for ITK image
iterators.

\item \textbf{\code{operator--()}} Decrements the iterator one position in the
negative direction.  Only the prefix decrement operator is defined for ITK
image iterators. Not all ITK iterators define this method.
\end{itemize}

Most iterators increment and decrement in the direction of the fastest
increasing image dimension.  When crossing a region boundary, the iterator will
wrap around the image, incrementing the next fastest increasing dimension.
As illustrated in figure~{\ref{fig:WalkingIterator}}, a typical iterator moves
across columns and down rows.  When it reaches the end of the last row in the
first slice, the iterator wraps to the beginning of the first row in the next
slice.  

Some iterators do not follow a predetermined path through their regions.  A
conditional iterator (section~\ref{sec:ConditionalIterators}), for example,
visits pixels only if they have certain values or connectivities.  Random
iterators, increment and decrement to random locations, and may visit a given
pixel location more than once.

\begin{figure}
\centering
%\includegraphics[width=0.9\textwidth]{}
%figure with small graphic illustrating algorithm & iterators plus some simple pseudocode.
\caption[Normal iterator path.]{Normal path of an iterator through an image}
\protect\label{fig:WalkingIterator}
\end{figure}

%Testing for location
An iterator can be queried to determine if it is at the end or the beginning of
its iteration region.  These methods are used as halting criteria for iteration
loops.  An iterator can also return the index of the image pixel to which it
points. 

\begin{itemize}
\item \textbf{\code{bool IsAtEnd()}} True if the iterator points to \emph{one
position past} the end of the iteration region.

\item \textbf{\code{bool IsAtBegin()}} True if the iterator points to the first
position in the iteration region.  The method is typically used to test for the
end of reverse iteration.

\item \textbf{\code{ImageIndex GetIndex()}} Returns the \code{itk::ImageIndex}
of the image pixel to which the iterator currently points.
\end{itemize}


%Accessing data.
Two methods are commonly defined for ITK iterators to access pixel values.

\begin{itemize}
\item \textbf{\code{PixelType Get()}} Returns the value of the pixel at the
iterator position.

\item \textbf{\code{void Set( PixelType )}}Sets the value of the pixel at the
iterator position.
\end{itemize}

% Describe efficiency due to inlining for all cases
The \code{Get} and \code{Set} methods are inlined and optimized for speed. For
most cases, calling either of these methods incurs no penalty over directly
dereferencing the memory pointer in the underlying image memory buffer.
\code{Get} and \code{Set} methods also support image adaptors (section~\ref{}).

There is one common case where \code{Get} and \code{Set} do incur a penalty.
The following line of code fetches, modifies, and then writes a value back to
the same pixel location.

\begin{verbatim}
it.Set( it.Get() + 1 );
\end{verbatim}

As written, this code requires one more memory dereference than necessary.  To
handle this case, some iterators define a third method.

\begin{itemize}
\item \textbf{\code{PixelType \& Value()}} Returns a reference to the pixel at
the iterator position.
\end{itemize}

The \code{Value} method can be either an lval or an rval in an expression.  This
makes it possible to rewrite our example code more efficiently.

\begin{verbatim}
it.Value()++;
\end{verbatim}

The \code{Value} method, however, cannot support the use of image adaptors.
Whenever possible, you should use \code{Get} and \code{Set} instead.  Because
ITK filters do not modify the contents of their input images, situations
calling for \code{Value} are less common than might be supposed.  More often
than not, an algorithm operates on two images, an input from which values are
only read (\code{Get}), and an output to which values are only written
(\code{Set}).

% Now give a psuedo code example for putting all of this together.
Using the methods described above, we can now write a simple example for
pixel-wise operations in any image region.  The following code writes the
square all of the values in an input image to an output image using two
iterators.

\begin{verbatim}
ConstIteratorType in(input_image,   input_image->GetRequestedRegion());
IteratorType out(output_image, input_image->GetRequestedRegion());

for (in.GoToBegin(), out.GoToBegin(); !in.IsAtEnd(); ++in, ++out)
{
  out.Set( in.Get() * in.Get() );
}
\end{verbatim}

Notice that both the input and output iterators are initialized over the same
region, that of \code{input\_image}.  This is good practice because it ensures
that the output iterator walks exactly the same set of pixel indicies as the
input iterator, but does not require that the output and input be the same
size.  The only requirement is that the output image must contain the requested
region of the input image.  Another advantage is that only one test for the end
of iteration is required in the \code{for} loop.

The input iterator in the previous example is of \code{const} type.  Most ITK
image iterators have a const and non-const version.  A non-const iterator
cannot be instantiated with a const \code{itk::Image} smart pointer.

Equivalent code can be written that iterates through the image in reverse.  The
syntax is slightly more awkward because the \emph{end} of the iteration region
as one past the last valid position, and we can only test whether the iterator
is strictly \emph{equal} to its beginning position.  It is often more
convenient to write reverse iteration in a \code{while} loop.

\begin{verbatim}
in.GoToEnd();
out.GoToEnd();
while ( ! in.IsAtBegin() )
{
  --in;
  --out;
  out.Set( in.Get() * in.Get() );
}

\end{verbatim}
% Need a paragraph or two about other image methods like GetIndex(), etc.  Are
%these universally defined?

%\begin{itemize}
%\item \textbf{\code{index GetIndex()}} 
%\item \textbf{\code{SetIndex(index)}}
%\end{itemize}

%\begin{itemize}
%\item \textbf{\code{operator==}}
%\item \textbf{\code{operator<}} 
%\item \textbf{\code{operator<=}}
%\item \textbf{\code{operator>}}
%\item \textbf{\code{operator>=}}
%\end{itemize}


% SetIndex()

% operator <, operator >, etc.

\section{Image Iterators}
\label{sec:ImageIterators}
%Introduction and overview
This section describes iterators that walk rectilinear regions in images and
reference a single pixel.  The \code{itk::ImageRegionIterator} is the basic,
general purpose ITK image iterator.  The rest of the
iterators described in this section are variations on
\code{itk::ImageRegionIterator} and incorporate specializations designed to 
speed up or encapsulate common tasks.

% Each of the iterators has a const and non-const version

\subsection{itk::ImageRegionIterator}
\label{sec:itkImageRegionIterator}
% Table which lists fetatures?
%./Common/itkImageRegionConstIterator.h
%./Common/itkImageRegionIterator.h
%(./Common/itkImageConstIterator.h base class)
%(./Common/itkImageIterator.h base class)
\input{ImageRegionIterator.tex}

The \code{itk::ImageRegionIterator} has been optimized for iteration speed.  It
is the first choice for doing pixelwise operations where location in the image
is not important.  

\subsection{itk::ImageRegionIteratorWithIndex}
\label{sec:itkImageRegionIteratorWithIndex}
%./Common/itkImageRegionConstIteratorWithIndex.h
%./Common/itkImageRegionIteratorWithIndex.h
%(./Common/itkImageConstIteratorWithIndex.h  base class )
%(./Common/itkImageIteratorWithIndex.h  base class )
The ``WithIndex'' family of iterators were designed for use in situations where
an algorithm makes extensive use of the iterator's index location. Unlike
\code{itk::ImageRegionIterator}, which calculates the index only when queried,
\code{itk::ImageRegionIteratorWithIndex} maintains its index location as a member variable
which is updated each time the iterator is incremented or decremented.
Otherwise, this iterator is very similar.  A penalty introduced on the
iteration speed, but is more efficient when repeatedly querying for the index.

\input{ImageRegionIteratorWithIndex.tex}

% A Note on encapsulation?
%\code{Itk::ImageRegionIteratorWithIndex} is a good example of how ITK iterators
%can save programmer effort by encapsulating common functionality.  Incrementing
%an N dimensional index over a subregion of an image is not trivial code to

\subsection{itk::ImageLinearIteratorWithIndex}
\label{sec:itkImageLinearIteratorWithIndex}
%./Common/itkImageLinearConstIteratorWithIndex.h
%./Common/itkImageLinearIteratorWithIndex.h
An \code{itk::ImageLinearIteratorWithIndex} is designed for line-by-line
processing of an image.  It walks a linear path along a selected image
direction parallel to one of the principle axes of the image. The image is
effectively indexed as a set of parallel lines spanning the selected image
dimension.

Like all other ITK image iterators, movement is constrained to within an image
region, $R$.  The line $\ell$ through which the iterator moves is defined by a
selected direction and an origin.  The origin itself can be iterated, and is
any of the pixels along the lower boundary of $R$.  $\ell$ extends from the
origin to the upper boundary of $R$.

Several additional methods are defined for this iterator to control movement
along the line $\ell$, and movement of the line origin within the image.

%Might need a figure here to describe this iterator.

\begin{itemize}
\item \textbf{\code{NextLine()}} Moves the iterator to the beginning pixel
location of the next line in the image.  The origin of the next line is
determined by incrementing the current origin along the fastest increasing
dimension of the subspace of the image that excludes the selected dimension.

\item \textbf{\code{PreviousLine()}} Moves the iterator to the \emph{last valid
pixel location} in the previous line. The origin of the previous line is
determined by decrementing the current origin along the fastest increasing
dimension of the subspace of the image that excludes the selected dimension.

\item \textbf{\code{(GoToBeginOfLine())}} Moves the iterator to the beginning
pixel of the current line.

\item \textbf{\code{(GoToEndOfLine())}}  Move the iterator to \emph{one past
the last valid} pixel of the current line.

\item \textbf{\code{(IsAtBeginOfLine())}} Returns true if the iterator points
to the beginning pixel of the current line.

\item \textbf{\code{(IsAtEndOfLine())}}  Returns true if the iterator points to
\emph{one position past the last valid} pixel of the current line.
\end{itemize}

\input{ImageLinearIteratorWithIndex.tex}

\subsection{itk::ImageSliceIteratorWithIndex}
\label{sec:itkImageSliceIteratorWithIndex}
%./Common/itkImageSliceConstIteratorWithIndex.
%./Common/itkImageSliceIteratorWithIndex.h
The \code{itk::ImageSliceIteratorWithIndex} is an extension of the
\code{itk::ImageLinearIteratorWithIndex}.  It adds a second dimension over
which iteration can be controlled, called the \emph{slice}.  A slice can be
thought of as a 2D plane of the image, oriented parallel to one of the
principle axes.  Any combination of line and slice directions can be handled by
this iterator.

%Need a figure here to illustrate?

In addition to those methods defined for
\code{itk::ImageLinearIteratorWithIndex}, the slice iterator defines the following.

\begin{itemize}
\item \textbf{\code{NextSlice()}} Moves the iterator to the beginning pixel
location of the next slice in the image.  The origin of the next slice is
determined by incrementing the current origin along the fastest increasing
dimension of the subspace of the image that excludes the selected slice and
line dimensions.

\item \textbf{\code{PreviousSlice()}} Moves the iterator to the \emph{last valid
pixel location} in the previous slice. The origin of the previous slice is
determined by decrementing the current origin along the fastest increasing
dimension of the subspace of the image that excludes the selected slice and
line dimensions.

\item \textbf{\code{(GoToBeginOfSlice())}} Moves the iterator to the beginning
pixel of the current slice.

\item \textbf{\code{(GoToEndOfSlice())}}  Move the iterator to \emph{one past
the last valid} pixel of the current slice.

\item \textbf{\code{(IsAtBeginOfSlice())}} Returns true if the iterator points
to the beginning pixel of the current slice.

\item \textbf{\code{(IsAtEndOfSlice())}}  Returns true if the iterator points to
\emph{one position past the last valid} pixel of the current slice.
\end{itemize}

\input{ImageSliceIteratorWithIndex.tex}


\subsection{itk::ImageRandomConstIteratorWithIndex}
\label{sec:itkImageRandomConstIteratorWithIndex}
%./Common/itkImageRandomConstIteratorWithIndex.h
%./Common/itkImageRandomIteratorWithIndex.h
Sometimes an algorithm may require a random sample of the pixel values in an
image. \code{itk::ImageRandomConstIteratorWithIndex} was developed for that
purpose. When incremented or decremented, the iterator simply jumps to a random
location in its image region.  

The user must specify a sample size when creating this iterator. The sample
size defines the end position for the iterator.  \Is

%\code{itk::ImageRandomConstIteratorWithIndex} may visit the same pixel location
%more than once.

\input{ImageRandomConstIteratorWithIndex}





\section{Conditional Iterators}
\label{sec:ConditionalIterators}
This section describes iterators that walk only pixels in an image region whose
values satisfy a condition.



%./Common/itkConditionalConstIterator.h (BaseClass)
%./Common/itkConditionalIterator.h (BaseClass)
%./Common/itkFloodFilledFunctionConditionalConstIterator.h (BaseClass)
%./Common/itkFloodFilledFunctionConditionalIterator.h (BaseClass)


%[ here are all classes where these filters are used:
% ./BasicFilters/itkConfidenceConnectedImageFilter.txx (ImageFunction)
% ./BasicFilters/itkConnectedThresholdImageFilter.txx (ImageFunction)
% ./BasicFilters/itkIsolatedConnectedImageFilter.txx (ImageFunction)
% ./BasicFilters/itkNeighborhoodConnectedImageFilter.txx (ImageFunction)
%
% ./Common/itkBinaryBallStructuringElement.txx (SpatialFunction)
% ./Common/itkBloxCoreAtomImage.txx (SpatialFunction)
% ./BasicFilters/itkBloxBoundaryPointToCoreAtomImageFilter.txx (SpatialFunction)
% ./BasicFilters/itkBloxBoundaryPointImageToBloxBoundaryProfileImageFilter.txx (SpatialFunction)
%]

\subsection{itk::FloodFilledImageFunctionConditionalIterator}
\label{itk::FloodFilledImageFunctionConditionalIterator}
%./Common/itkFloodFilledImageFunctionConditionalConstIterator.h
%./Common/itkFloodFilledImageFunctionConditionalIterator.h


\subsection{itk::FloodFilledSpatialFunctionConditionalIterator}
\label{itk::FloodFilledSpatialFunctionConditionalIterator}
%./Common/itkFloodFilledSpatialFunctionConditionalConstIterator.h
%./Common/itkFloodFilledSpatialFunctionConditionalIterator.h


\section{Neighborhood Iterators}
\label{sec:NeighborhoodIterators}
This section describes iterators which walk rectilinear regions and reference a
local neighborhood of image pixels.

%Do not support image adaptors

%[Introduction goes here]
%[Be sure to reference Section: Neighborhood Filters]

% Example: derivative
% Example: convolution filtering
% Example: boundary conditions
% Example: walking faces

\subsection{itk::NeighborhoodIterator}
\label{sec:itkNeighborhoodIterator}
./Common/itkConstNeighborhoodIterator.h
./Common/itkNeighborhoodIterator.h

\subsection{itk::ShapedNeighborhoodIterator}
\label{sec:itkShapedNeighborhoodIterator}
./Common/itkConstShapedNeighborhoodIterator.h
./Common/itkShapedNeighborhoodIterator.h


% ADD A SECTION WITH TIPS, SUGGESTIONS ON USING ITERATORS?  EXTENDING ITERATORS?

