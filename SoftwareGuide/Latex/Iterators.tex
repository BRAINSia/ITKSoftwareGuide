\chapter{Iterators}

\index{Iterator!Concept}
\index{Generic Programming}
This chapter introduces the \emph{image iterator}, a fundamental and important
generic programming construct for image processing in ITK.  An iterator is a
generalization of the familiar C pointer, used to access data in memory.  ITK
has a wide variety of iterators, some of which are highly specialized to
simplify common image processing tasks.

The section that follows is a brief introduction that defines iterators in the
context of ITK and the \code{itk::Image} and describes their common programming
interface.  The specific types and instances of iterators are documented in the
last sections of this chapter, along with some examples of how they can be
used.

\section{Overview}
\label{sec:IteratorsIntroduction}
% Further define iterators in the context of generic programming.
Generic programming models define functionally independent components called
\emph{containers} and \emph{algorithms}.  Algorithms operate on data
within containers to produce some result.  Iterators keep these two components
independent of one another by presenting the algorithm object with a generic
interface that it can use to fetch and store data in any container object.
Using iterators, algorithm code can be written that does not depend on any one
specific representation of data.

% Define iterators in the context of ITK generic programming. 
In ITK, we use the iterator concept to write image processing code that can be
instantiated and run on \code{itk::Image}s of any combination of pixel type,
dimensionality, and pixel container type (see itk::Image).
Figure~\ref{fig:ImageIterators} illustrates how image iterators form the glue
between ITK filters (algorithms) and different ITK image types (data
containers). A filter processes data in an image one pixel at a time.  The
\emph{iterator} is incremented at each \emph{iteration} of the inner processing
loop.

\begin{figure}
\centering
%\includegraphics[width=0.9\textwidth]{}
%figure with small graphic illustrating algorithm & iterators plus some simple pseudocode.
\caption[Image iterators in ITK]{Image iterators in ITK}
\protect\label{fig:ImageIterators}
\end{figure}

% List advantages: code size/reuse. increased performance over set/get in image, allow to ignore
% dimensionality. 
There are many advantages to using image iterators over direct pixel access
through \code{itk::Image::Set} and \code{itk::Image::Get} methods.  Code is more
compact and often generalizes automatically to higher dimensions, algorithms
run much faster, and many tasks such as multithreading, neighborhood image
processing, and working with non-rectilinear regions of interest are greatly
simplified.  These advantages will be illustrated in the sections to follow. 

%In fact, with iterators,
%algorithms often generalize to higher dimensions automatically.  Note how the
%code in figure~\ref{fig:ImageIterators} is equally correct for images of two,
%three, or even ten dimensions.  The alternative to using iterators in this
%example would be a set of nested \code{for} loops.  Such nested loops would
%also require knowing the size of the image.  


% Talk about extensions to iterator concept, iterating through nonrectilinear
% regions.  Encapsulating complex tasks such as managing pointers to pixel
% neighbors in ND.
%Image iterators can encapsulate much of the complexity of writing many common
%algorithms.  Some ITK iterators, for example, have been designed to walk
%non-rectilinear paths through an image, allowing specialized processing over
%regions of interest or boundary pixels.  Other iterators efficiently manage
%access to entire N-dimensional neighborhoods, making localized image processing
%algorithms simple to write and to generalize to higher dimensions.


[describe a standard ITK interface]
Most ITK iterators define the following methods. [a bulleted definition list?]
        GoToBegin()
        GoToEnd()
        IsAtEnd()
        IsAtBegin()
        Operator++
        Operator--

[where traditional iterators overload the * operator, in ITK we have chosen to
use Set Get]
        Get
        Set
Set methods are only defined in const iterators.
Some iterators also supply a Value() method to allow dereferencing and modifying a
pixel value in a single step.  For example: [give example of how if you wanted
to do something like *it++ you would have to write it as it.Set(it.Get() + 1),
whereas it.Value()++ saves one dereference]

[image adaptors]
The use of Set, Get also supports image adaptors (section reference?)

[three basic types of image iterators: single pixel access methods, single
pixel methods which walk special paths, neighborhood access methods,]

The following sections describe the various ITK image iterator types.

\section{Image Iterators}
\label{sec:ImageIterators}



\subsection{itk::ImageRegionIterator}
\label{sec:itkImageRegionIterator}
./Common/itkImageRegionConstIterator.h
./Common/itkImageRegionIterator.h
(./Common/itkImageConstIterator.h base class)
(./Common/itkImageIterator.h base class)

Describe typical use cases.

Describe any special peculiarities of the interface and the guarantees of
complexity, etc.  Guarantees: will walk a region in same order on two different
images, no guarantees of what that order will be necessarily.

Example code

\subsection{itk::ImageRegionIteratorWithIndex}
\label{sec:itkImageRegionIteratorWithIndex}
./Common/itkImageRegionConstIteratorWithIndex.h
./Common/itkImageRegionIteratorWithIndex.h
(./Common/itkImageConstIteratorWithIndex.h  base class )
(./Common/itkImageIteratorWithIndex.h  base class )

\subsection{itk::ImageSliceIteratorWithIndex}
\label{sec:itkImageSliceIteratorWithIndex}
./Common/itkImageSliceConstIteratorWithIndex.
./Common/itkImageSliceIteratorWithIndex.h

\subsection{itk::ImageLinearIteratorWithIndex}
\label{sec:itkImageLinearIteratorWithIndex}
./Common/itkImageLinearConstIteratorWithIndex.h
./Common/itkImageLinearIteratorWithIndex.h

\subsection{itk::ImageRandomConstIteratorWithIndex}
\label{sec:itkImageRandomConstIteratorWithIndex}
./Common/itkImageRandomConstIteratorWithIndex.h
./Common/itkImageRandomIteratorWithIndex.h


\section{Conditional Iterators}
\label{sec:ConditionalIterators}

[Introduction and overview]

./Common/itkConditionalConstIterator.h (BaseClass)
./Common/itkConditionalIterator.h (BaseClass)
./Common/itkFloodFilledFunctionConditionalConstIterator.h (BaseClass)
./Common/itkFloodFilledFunctionConditionalIterator.h (BaseClass)


%[ here are all classes where these filters are used:
% ./BasicFilters/itkConfidenceConnectedImageFilter.txx (ImageFunction)
% ./BasicFilters/itkConnectedThresholdImageFilter.txx (ImageFunction)
% ./BasicFilters/itkIsolatedConnectedImageFilter.txx (ImageFunction)
% ./BasicFilters/itkNeighborhoodConnectedImageFilter.txx (ImageFunction)
%
% ./Common/itkBinaryBallStructuringElement.txx (SpatialFunction)
% ./Common/itkBloxCoreAtomImage.txx (SpatialFunction)
% ./BasicFilters/itkBloxBoundaryPointToCoreAtomImageFilter.txx (SpatialFunction)
% ./BasicFilters/itkBloxBoundaryPointImageToBloxBoundaryProfileImageFilter.txx (SpatialFunction)
%]

\subsection{itk::FloodFilledImageFunctionConditionalIterator}
\label{itk::FloodFilledImageFunctionConditionalIterator}
./Common/itkFloodFilledImageFunctionConditionalConstIterator.h
./Common/itkFloodFilledImageFunctionConditionalIterator.h


\subsection{itk::FloodFilledSpatialFunctionConditionalIterator}
\label{itk::FloodFilledSpatialFunctionConditionalIterator}
./Common/itkFloodFilledSpatialFunctionConditionalConstIterator.h
./Common/itkFloodFilledSpatialFunctionConditionalIterator.h


\section{Neighborhood Iterators}
\label{sec:NeighborhoodIterators}

[Introduction goes here]
[Be sure to reference Section: Neighborhood Filters]

% Example: derivative
% Example: convolution filtering
% Example: boundary conditions
% Example: walking faces

\subsection{itk::NeighborhoodIterator}
\label{sec:itkNeighborhoodIterator}
./Common/itkConstNeighborhoodIterator.h
./Common/itkNeighborhoodIterator.h

\subsection{itk::ShapedNeighborhoodIterator}
\label{sec:itkShapedNeighborhoodIterator}
./Common/itkConstShapedNeighborhoodIterator.h
./Common/itkShapedNeighborhoodIterator.h






















