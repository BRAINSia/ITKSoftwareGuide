\chapter{Iterators}
\label{sec:ImageIteratorsChapter}
\index{Iterators!image|(}
\index{Generic Programming}
This chapter introduces the \emph{image iterator}, a fundamental and important
generic programming construct for image processing in ITK.  An iterator is a
generalization of the familiar C-Language pointer used to reference data in
memory.  ITK has a wide variety of image iterators, some of which are highly
specialized to simplify common image processing tasks.

The next section is a brief introduction that defines iterators in the context
of ITK.  Section ~\ref{sec:IteratorsInterface} described the programming
interface common to most ITK image iterators.  Specific ITK iterator types and
examples of how they are used are documented in
sections~\ref{sec:ImageIterators}--\ref{sec:NeighborhoodIterators}.

\section{Introduction}
\label{sec:IteratorsIntroduction}
% Further define iterators in the context of generic programming.
\index{generic programming}
\index{Iterators!definition of}
Generic programming models define functionally independent components called
\emph{containers} and \emph{algorithms}.  Container objects store data and
algorithms operate on that data.  To access data in containers, algorithms use
a third class of objects called \emph{iterators}.  An iterator is an
abstraction of a memory pointer.  Every container type must define its own
iterator type, but all iterators are written with a common interface.  This
common interface allows algorithm code to reference data in a generic way,
maintaining functional independence between algorithms and containers.

The iterator is so named because it is used for \emph{iterative}, sequential
access of container values.  Iterators appear in \code{for} and
\code{while} loop constructs, visiting each data point in turn.  A C-Language pointer,
for example, is a type of iterator.  It can be moved forward (incremented) and
backward (decremented) through memory to sequentially reference elements of an
array. Many iterator implementations have an interface similar to the
C-Language pointer interface. 

\index{Iterators!advantages of}
In ITK we use iterators to write generic image processing code for
\doxygen{Image}s instantiated with different combinations of pixel type, pixel
container type, and dimensionality.  Because ITK image iterators are
specifically designed to work with \emph{image} containers, their interface and
implementation is optimized for image processing tasks.

Writing image processing code in ITK with iterators has many specific
advantages over using the \doxygen{Image} interface directly.  Code is more
compact and often generalizes automatically to higher dimensions, algorithms
run much faster, and iterators simplify tasks such as multithreading,
neighborhood image processing, and working with non-rectilinear regions of
interest.


\section{Programming Interface}
\label{sec:IteratorsInterface}

\index{Iterators!programming interface|(}
%Creating iterators
The section describes the programming interface for ITK image iterators.  Not
all image iterators implement the full interface, and some define additional
methods.  When a specific iterator type defines any additions or restrictions to this
interface, it is noted in that iterator's documentation.

\subsection{Creating Iterators}
\label{sec:CreatingIterators}

\index{Iterators!construction of}
All image iterators have at least one template parameter: the image type over
which they iterate.  There is no restriction on the dimensionality of the image
or on the pixel type of the image.

\index{Iterators!and image regions}

There are always at least two arguments to an ITK image iterator constructor.
The first argument is a smart pointer to an \doxygen{Image}.  This is the
image to iterate over. The second argument is an
\doxygen{ImageRegion} that specifies the \emph{iteration region}.  The
iteration region is the rectilinear area of the image that iteration is
constrained within. Valid iteration regions are any subregions of the image
wholly contained in the current \code{BufferedRegion}.  See
section~\ref{sec:ImageSection} for more information on image regions. 


\index{Iterators!const}
Most ITK image iterators have a const and non-const version.  A non-const
iterator cannot be instantiated with a const \doxygen{Image} smart pointer.
Const versions of iterators do not allow modification of the values in the
image over which they iterate.

Here is an example of defining and constructing an iterator using the
\doxygen{ImageRegionIterator}.  For more examples, see
sections~\ref{sec:ImageIterators}--\ref{sec:NeighborhoodIterators}.

\small
\begin{verbatim}
typedef itk::Image<float, 3> ImageType;
typedef itk::ImageRegionConstIterator< ImageType > ConstIteratorType;
typedef itk::ImageRegionIterator< ImageType > IteratorType;

ImageType::Pointer image = SomeFilter->GetOutput();

ConstIteratorType constIterator( image, image->GetRequestedRegion() );
IteratorType iterator( image, image->GetRequestedRegion() );
\end{verbatim}
\normalsize

\subsection{Moving Iterators}
\label{sec:MovingIterators}
An iterator is described as \emph{walking} its iteration region.  At any time,
the iterator will reference (point to) one pixel location, denoted by an ND
grid index, within that region. \emph{Forward iteration} runs from the beginning of the iteration
region to the end of the iteration region.  \emph{Reverse iteration},
goes from just past the end to the beginning.  There are two
corresponding starting positions for iterators, the \emph{begin} position and
the \emph{end} position.  An iterator can be moved directly to either of these
two positions using the following methods.

\index{forward iteration}
\index{reverse iteration}
\index{iteration region}
\index{Iterators!GoToBegin()}

\begin{itemize}
\item \textbf{\code{GoToBegin()}} Points the iterator to the first valid
data element in the region.

\index{Iterators!GoToEnd()}
\item \textbf{\code{GoToEnd()}} Points the iterator to \emph{one position past}
the last valid element in the region.
\end{itemize}

Note that the end position is not located within the iteration region.  This is
important to remember because attempting to dereference an iterator at its end
position will have undefined results.

%Moving iteators
ITK iterators define forward and reverse movement through their regions by
overloading the increment and decrement operators.

\index{Iterators!operator++()}
\begin{itemize}
\item \textbf{\code{operator++()}} Increments the iterator one position in the
positive direction.  Only the prefix increment operator is defined for ITK image
iterators.

\index{Iterators!operator--}
\item \textbf{\code{operator--()}} Decrements the iterator one position in the
negative direction.  Only the prefix decrement operator is defined for ITK
image iterators. 
\end{itemize}

Figure~\ref{fig:WalkingIterator} illustrates typical iterator movement over
an image region.  Most iterators increment and decrement in the direction of
the fastest increasing image dimension, wrapping to the first position in the
next higher dimension at region boundaries.  In other words, this means an
iterator first moves across columns, then down rows, then from slice to slice,
etc.

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{IteratorFigure1.eps}
\itkcaption[ITK image iteration]{Normal path of an iterator through an image.  The
iteration region is shown in a darker shade.  An arrow denotes a single iterator
step, the result of one \code{++} operation.}
\protect\label{fig:WalkingIterator}
\end{figure}

In addition to sequential iteration through an image, some iterators may define
random access operators.  Unlike the increment operators, random access
operators may not be optimized for speed and require some knowledge of the
dimensionality of the image and the extent of the iteration region.  

\begin{itemize}
\index{Iterators!operator+=()}
\item \textbf{\code{operator+=( Offset )}} Moves the iterator to the pixel
position at the current index plus the specified ND \code{itk::Offset}. 

\index{Iterators!operator-=()}
\item \textbf{\code{operator-=( Offset )}} Moves the iterator to the pixel
position at the current index minus the specified ND \code{itk::Offset}.
\end{itemize}

One final method is also defined for most iterators to move an iterator to an
absolute image index position.

\begin{itemize}
\index{Iterators!SetPosition()}
\item \textbf{\code{SetPosition( Index )}} Moves the iterator to the given
\code{itk::Index} position.
\end{itemize}

The \code{SetPosition} method may be extremely slow for more complicated
iterator types. In general, it should only be used for setting a starting
iteration position, like you would use \code{GoToBegin()} or \code{GoToEnd()}.

Some iterators do not follow a predictable path through their iteration regions
and have no fixed beginning or ending pixel locations.  A conditional iterator
(section~\ref{sec:ConditionalIterators}), for example, visits pixels only if
they have certain values or connectivities.  Random iterators, increment and
decrement to random locations, and may visit a given pixel location more than
once.

%Testing for location
An iterator can be queried to determine if it has reached the end or the
beginning of its iteration region.  These methods are used as halting criteria
for iteration loops.

\begin{itemize}
\index{Iterators!IsAtEnd()}
\item \textbf{\code{bool IsAtEnd()}} True if the iterator points to \emph{one
position past} the end of the iteration region.

\index{Iterators!IsAtBegin()}
\item \textbf{\code{bool IsAtBegin()}} True if the iterator points to the first
position in the iteration region.  The method is typically used to test for the
end of reverse iteration.

\end{itemize}

An iterator can also report its current image index position.

\begin{itemize}
\index{Iterators!GetIndex()}
\item \textbf{\code{ImageIndex GetIndex()}} Returns the \doxygen{Index}
of the image pixel that the iterator currently points to.
\end{itemize}

% A note on bounds checking
\index{Iterators!and bounds checking}
For efficiency, most ITK image iterators do not perform bounds checking.  What
this means is that it is possible to move an iterator to a location outside its
valid iteration region.  Dereferencing the iterator at an out-of-bounds location
will produce an undefined result. It is left to the user to make sure the
iterator remains in bounds.  For most applications,  bounds checking only
requires the standard test for \code{IsAtEnd()} or \code{IsAtBegin()} condition at each
iteration step.  Calling \code{operator+=},  \code{operator-=}, or
\code{SetPosition} on an iterator to perform random access operations may
warrant more careful measures. 

\subsection{Accessing Data}
\label{sec:AccessingData}
ITK image iterators define two basic methods for reading and writing pixel
values.

\begin{itemize}
\index{Iterators!Get()}
\item \textbf{\code{PixelType Get()}} Returns the value of the pixel at the
iterator position.

\index{Iterators!Set()}
\item \textbf{\code{void Set( PixelType )}} Sets the value of the pixel at the
iterator position.  Not defined for const versions of iterators.
\end{itemize}

% Describe efficiency due to inlining for all cases
The \code{Get} and \code{Set} methods are inlined and optimized for speed. In
most cases, a call to one of these methods incurs no penalty over directly
dereferencing the memory pointer in the underlying image memory buffer.
\code{Get} and \code{Set} methods also support the use of image adaptors
(section~\ref{sec:ImageAdaptors}).
\index{Iterators!support of adaptors}

There are some common cases, however, where \code{Get} and \code{Set} do incur a
penalty. Consider the following code, which fetches, modifies, and then writes
a value back to the same pixel location.

\small
\begin{verbatim}
it.Set( it.Get() + 1 );
\end{verbatim}
\normalsize

As written, this code requires one more memory dereference than necessary.  To
handle this case, some iterators define a third data access method.

\begin{itemize}
\index{Iterators!Value()}
\item \textbf{\code{PixelType \& Value()}} Returns a reference to the pixel at
the iterator position.
\end{itemize}

The \code{Value()} method can be either an lval or an rval in an expression.  It
has all the properties of \code{operator*}.  The \code{Value()} method makes it
possible to rewrite our example code more efficiently.

\small
\begin{verbatim}
it.Value()++;
\end{verbatim}
\normalsize

Consider using the \code{Value()} method when a call to a pixel type's
\code{operator=} method is non-trivial, for example, when working
with multiple-component data such as vectors.

The disadvantage of using \code{Value()} over \code{Get()} and \code{Set()} is
that is cannot support image adaptors. Whenever possible, use \code{Get()} and
\code{Set()} instead.  Because ITK filters do not modify the contents of their
input images, situations calling for \code{Value()} are less common than might
be supposed.  More often than not, an algorithm operates on two images, an
input from which values are only read (\code{Get()}), and an output to which
values are only written (\code{Set()}).


\subsection{Iteration Loops}
\label{sec:IterationExample}
% Now give a psuedo code example for putting all of this together.
Using the methods described in the previous sections, we can now write a simple
example for pixel-wise operations in any image region.  The following code
calculates the squares all values in an input image and writes them to an
output image.

\small
\begin{verbatim}
ConstIteratorType in( inputImage,   inputImage->GetRequestedRegion() );
IteratorType out( outputImage, inputImage->GetRequestedRegion() );

for ( in.GoToBegin(), out.GoToBegin(); !in.IsAtEnd(); ++in, ++out )
  {
  out.Set( in.Get() * in.Get() );
  }
\end{verbatim}
\normalsize

\index{Iterators!and image regions}
Notice that both the input and output iterators are initialized over the same
region, the \code{RequestedRegion} of \code{inputImage}.  This is good
practice because it ensures that the output iterator walks exactly the same set
of pixel indicies as the input iterator, but does not require that the output
and input be the same size.  The only requirement is that the output image must
contain the requested region of the input image, which will generally be
the case when writing ITK pipeline filter objects.  Another advantage is that
only one test for the end of iteration is required in the \code{for} loop.

\index{reverse iteration}
Equivalent code can be written by iterating through the image in reverse.
The syntax is slightly more awkward because the \emph{end} of the
iteration region is not a valid position and we can only test whether the
iterator is strictly \emph{equal} to its beginning position.  It is often more
convenient to write reverse iteration in a
\code{while} loop.

\small
\begin{verbatim}
in.GoToEnd();
out.GoToEnd();
while ( ! in.IsAtBegin() )
  {
  --in;
  --out;
  out.Set( in.Get() * in.Get() );
  }
\end{verbatim}
\normalsize

%\begin{itemize}
%\item \textbf{\code{operator==}}
%\item \textbf{\code{operator<}} 
%\item \textbf{\code{operator<=}}
%\item \textbf{\code{operator>}}
%\item \textbf{\code{operator>=}}
%\end{itemize}

%operator +=, -=, etc

% SetIndex()

% operator <, operator >, etc.

\index{Iterators!programming interface|)}
\section{Image Iterators}
\label{sec:ImageIterators}
%Introduction and overview
This section describes iterators that walk rectilinear regions in images and
reference a single pixel.  The \doxygen{ImageRegionIterator} is the basic,
general purpose ITK image iterator.  The rest of the iterators described in
this section are variations on \doxygen{ImageRegionIterator} and
incorporate specializations designed to speed up or encapsulate common tasks.

% Each of the iterators has a const and non-const version

\subsection{itk::ImageRegionIterator}
\index{itk::ImageRegionIterator|(}
\label{sec:itkImageRegionIterator}
\input{ImageRegionIterator.tex}
\index{itk::ImageRegionIterator|)}

\subsection{itk::ImageRegionIteratorWithIndex}
\label{sec:itkImageRegionIteratorWithIndex}
\index{itk::ImageRegionIteratorWithIndex|(}
\input{ImageRegionIteratorWithIndex.tex}
\index{itk::ImageRegionIteratorWithIndex|)}

\subsection{itk::ImageLinearIteratorWithIndex}
\label{sec:itkImageLinearIteratorWithIndex}
\index{itk::ImageLinearIteratorWithIndex|(}
\input{ImageLinearIteratorWithIndex.tex}
\index{itk::ImageLinearIteratorWithIndex|)}

\subsection{itk::ImageSliceIteratorWithIndex}
\label{sec:itkImageSliceIteratorWithIndex}
\index{itk::ImageSliceIteratorWithIndex|(}
\input{ImageSliceIteratorWithIndex.tex}
\index{itk::ImageSliceIteratorWithIndex|)}

\subsection{itk::ImageRandomConstIteratorWithIndex}
\label{sec:itkImageRandomConstIteratorWithIndex}
\index{itk::ImageRandomConstIteratorWithIndex|(}
\input{ImageRandomConstIteratorWithIndex}
\index{itk::ImageRandomConstIteratorWithIndex|)}

\section{Conditional Iterators}
\index{Iterators!conditional|(}
\label{sec:ConditionalIterators}
This section describes iterators that walk only pixels in an image region whose
values satisfy a specified condition.  The condition is usually based on some
function of the image values, such as comparing to a threshold.  When the
condition function returns \code{true} at a pixel location, the iterator
includes that location in its path.  The biggest use of these iterators is for
walking non-rectilinear regions of interest, such as might be defined by
implicit geometric shape functions or connected component regions.

%./Common/itkConditionalConstIterator.h (BaseClass)
%./Common/itkConditionalIterator.h (BaseClass)
%./Common/itkFloodFilledFunctionConditionalConstIterator.h (BaseClass)
%./Common/itkFloodFilledFunctionConditionalIterator.h (BaseClass)

%[ here are all classes where these filters are used:
% ./BasicFilters/itkConfidenceConnectedImageFilter.txx (ImageFunction)
% ./BasicFilters/itkConnectedThresholdImageFilter.txx (ImageFunction)
% ./BasicFilters/itkIsolatedConnectedImageFilter.txx (ImageFunction)
% ./BasicFilters/itkNeighborhoodConnectedImageFilter.txx (ImageFunction)
%
% ./Common/itkBinaryBallStructuringElement.txx (SpatialFunction)
% ./Common/itkBloxCoreAtomImage.txx (SpatialFunction)
% ./BasicFilters/itkBloxBoundaryPointToCoreAtomImageFilter.txx (SpatialFunction)
% ./BasicFilters/itkBloxBoundaryPointImageToBloxBoundaryProfileImageFilter.txx (SpatialFunction)
%]

\subsection{itk::FloodFilledImageFunctionConditionalIterator}
\label{itk::FloodFilledImageFunctionConditionalIterator}
\index{itk::FloodFilledImageFunctionConditionalIterator|(}
%./Common/itkFloodFilledImageFunctionConditionalConstIterator.h
%./Common/itkFloodFilledImageFunctionConditionalIterator.h
\index{itk::FloodFilledImageFunctionConditionalIterator|)}

\subsection{itk::FloodFilledSpatialFunctionConditionalIterator}
\label{itk::FloodFilledSpatialFunctionConditionalIterator}
\index{itk::FloodFilledSpatialFunctionConditionalIterator|(}
%./Common/itkFloodFilledSpatialFunctionConditionalConstIterator.h
%./Common/itkFloodFilledSpatialFunctionConditionalIterator.h
\index{itk::FloodFilledImageFunctionConditionalIterator|)}
\index{Iterators!conditional|)}

\section{Neighborhood Iterators}
\label{sec:NeighborhoodIterators}
\index{Iterators!neighborhood|(}
In ITK, a pixel neighborhood is loosely defined as a small set of pixels that
are locally adjacent to one another in an image.  The size and shape
of a neighborhood, as well the connectivity among pixels in a neighborhood,
may vary with the application.

Many image processing algorithms perform local, neighborhood-based
calculations.  In other words, the result at an ND pixel index $i$ is computed
from the values of other pixels in the neighborhood of $i$. Consider finite
difference operations in 2D.  A derivative at pixel index $i = (j, k)$, for
example, is taken as a weighted difference between the values at $(j+1, k)$
and $(j-1, k)$. Other common examples of neighborhood operations include
convolution filtering and image morphology.

This section describes a class of ITK image iterators that are designed for
working with pixel neighborhoods. An ITK neighborhood iterator walks an image
region just like a normal image iterator, but instead of referencing just one
pixel at a time, it points to an entire ND neighborhood of pixels around each
pixel. Extensions to the normal ITK iterator interface provide read and write
access to all neighborhood pixels, as well as other useful information
such as the size, extent, and location of the neighborhood.

The standard ITK iterator operations defined in
section~\ref{sec:IteratorsInterface} are also valid for neighborhood iterators.
Neighborhood iterators use the same forward, reverse, and random access
iteration code as normal ITK iterators.
Figure~\ref{fig:WalkingNeighborhoodIterator} illustrates the concept of the
neighborhood iterator and shows its path through an iteration region.  Note
that the \emph{center} of neighborhood iterator is always positioned over its
current index, with all other neighborhood pixel indicies determined from that
center position.

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{NeighborhoodIteratorFigure1.eps}
\itkcaption[ITK neighborhood iterator iteration]{Path of a neighborhood
iterator through an image.  The iteration region is shown in a darker
shade and the extent of the iterator is indicated by the hashing. }
\protect\label{fig:WalkingNeighborhoodIterator}
\end{figure}

\index{Neighborhood iterators!construction of}
In addition to the standard image pointer and iteration region
(section~\ref{sec:IteratorsInterface}), neighborhood iterator constructors also
require an argument to describe the extent of the neighborhood.  Neighborhood
extent is expressed as the symmetric distance from the center of the
neighborhood in an ND array called the \emph{radius}. Each element $d$ of the
radius, where $N$ is the dimensionality of the neighborhood and $0 < d < N$,
gives the extent of the neighborhood in pixels for dimension $N$.  The length
of each face of the resulting ND hypercube is $2d + 1$ pixels, a distance of
$d$ on either side of the single pixel at the neighbor center.
Figure~{\ref{fig:NeighborhoodIteratorRadius} illustrates these concepts for a
2D iterator.

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{NeighborhoodIteratorFigure1.eps}
\itkcaption[ITK image iteration]{Path of a neighborhood iterator through an image.  The
iteration region is shown in a darker shade. An arrow denotes a single iterator
step, the result of one \code{++} operation.  }
\protect\label{fig:WalkingNeighborhoodIterator}
\end{figure}

After construction, the radius of the neighborhood iterator is available
through the \code{GetRadius} method.  A few other methods provide some useful
information about the iterator and its underlying image.

\begin{itemize}

\item \textbf{\code{const ImageType *GetImagePointer()}} Returns the pointer to
the image referenced by the iterator.

\item \textbf{\code{unsigned long Size()}} Returns the size in pixels of the
neighborhood.

\item \textbf{\code{itk::Size GetRadius()}} Returns the ND radius of the
neighborhood.

\end{itemize}


The neighborhood iterator interface extends the normal ITK iterator interface
for setting and getting pixel values.  The iterator stores references to all of
the neighborhood pixels in a linear array and pixels can be dereferenced
directly using their array positions.  The \code{Size} method above returns the
size of this array.  Array positions are incremented along the fastest
increasing image dimension: first column, then row, then slice, and so on.  The
center pixel is always at position $n/2$, where $n$ is the size of the array.
Figure~\ref{fig:NeighborhoodArray}a illustrates this idea in several 2D
examples.

\begin{itemize}

\item \textbf{\code{PixelType GetPixel(const unsigned int i}} Returns the value
of the pixel at neighborhood position \code{i}.

\item \textbf{\code{PixelType SetPixel(const unsigned int i, PixelType p}} Sets
the value of the pixel at position \code{i} to \code{p}.

\end{itemize}

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{NeighborhoodIteratorFigure1.eps}
\itkcaption[Memory layout and pixel access in a neighborhood iterator.]{Pixel references
in a neighborhood iterator are stored in an array. The indicies of this array
increase with the fastest increasing image dimension.}
\protect\label{fig:NeighborhoodArray}
\end{figure}

Another way to think about a pixel location in a neighborhood is as an ND
offset from the neighborhood center.  The upper-left corner of a $3x3x3$
neighborhood, for example, can be described by offset $(-1, -1, -1)$. The
bottom-right corner of the same neighborhood is at offset $(1, 1, 1)$.  
Figure~\ref{fig:NeighborhoodArray}b illustrates several 2D examples.

\begin{itemize}

\item \textbf{\code{PixelType GetPixel(const itk::Offset \&o}} Get the value of
the pixel at the position offset \code{o} from the neighborhood center.

\item \textbf{\code{PixelType SetPixel(const itk::Offset \&o, PixelType p}} Set
the value at the position offset \code{o} from the neighborhood center to
the value \code{p}.

\end{itemize}

The neighborhood iterators also provide a shorthand for setting and getting the
value at the center of the neighborhood.

\index{NeighborhoodIterators!}
\begin{itemize}

\item \textbf{\code{PixelType GetCenterPixel()}} Gets the value at the center
of the neighborhood.

\item \textbf{\code{void SetCenterPixel(PixelType p)}} Sets the value at the
center of the neighborhood to the value \code{p}

\end{itemize}

Another shorthand for setting and getting values can be used for pixels that
lie some integer distance from the neighborhood center along one of the image axes.

\index{NeighborhoodIterators!}
\begin{itemize}

\item \textbf{\code{PixelType GetNext(unsigned int d)}} Get the value
immediately adjacent to the neighborhood center in the positive direction along
the \code{d} axis.

\item \textbf{\code{void SetNext(unsigned int d, PixelType p)}} Set the value
immediately adjacent to the neighborhood center in the positive direction along
the \code{d} axis to the value \code{p}.

\item \textbf{\code{PixelType GetPrevious(unsigned int d)}} Get the value
immediately adjacent to the neighborhood center in the negative direction along
the \code{d} axis.

\item \textbf{\code{void SetPrevious(unsigned int d, PixelType p)}} Set the value
immediately adjacent to the neighborhood center in the negative direction along
the \code{d} axis to the value \code{p}.

\item \textbf{\code{PixelType GetNext(unsigned int d, unsigned int s)}} Get the
value of the pixel located \code{s} pixels from the neighborhood center in the positive
direction along the \code{d} axis.

\item \textbf{\code{void SetNext(unsigned int d, unsigned int s, PixelType p)}}
Set the value of the pixel located \code{s} pixels from the neighborhood center
in the positive direction along the \code{d} axis to value \code{p}.

\item \textbf{\code{PixelType GetPrevious(unsigned int d, unsigned int s)}} Get the
value of the pixel located \code{s} pixels from the neighborhood center in the positive
direction along the \code{d} axis.
 
\item \textbf{\code{void SetPrevious(unsigned int d, unsigned int s, PixelType p)}}  
Set the value of the pixel located \code{s} pixels from the neighborhood center
in the positive direction along the \code{d} axis to value \code{p}.

\end{itemize}

It is also possible to extract or set all of the neighborhood values from an iterator
at once using a regular ITK neighborhood object.  This may be useful in
algorithms that perform a particularly large number of calculations in the
neighborhood and would otherwise require multiple dereferences of the same pixels.

\begin{itemize}

\item \textbf{\code{itk::NeighborhoodType GetNeighborhood()}} Return a
\code{itk::Neighborhood} of the same size and shape as the neighborhood
iterator and contains all of the values at the iterator position.

\item \textbf{\code{void SetNeighborhood(itk::Neighborhoodtype \&N)}} Set all
of the values in the neighborhood at the iterator position to those contained
in \code{itk::Neighborhood N}, which must be the same size and shape as the iterator.

\end{itemize}

Several additional methods are defined to provide information about the
neighborhood and the pixel locations within it.

\index{NeighborhoodIterators!}
\begin{itemize}

\item \textbf{\code{itk::IndexType GetIndex()}} Return the \code{itk::Image}
index of the center pixel of the neighborhood iterator.

\item \textbf{\code{itk::ImageIndex GetIndex(itk::Offset o)}} Return the
\code{itk::Image} index of the pixel at offset \code{o} from the neighborhood center.

\item \textbf{\code{itk::ImageIndex GetIndex(unsigned int i)}} Return the
\code{itk::Image} index of the pixel at array position \code{i}.

\item \textbf{\code{itk::Offset GetOffset(unsigned int i)}}  Return the offset
from the neighborhood center of the pixel at array position \code{i}.

\item \textbf{\code{unsigned long GetNeighborhoodIndex(itk::Offset o)}} Return
the array position of the pixel at offset \code{o} from the neighborhood center.

\item \textbf{\code{std::slice GetSlice(unsigned int n)}} Return a
\code{std::slice} through the iterator neighborhood along axis \code{n}.

\end{itemize}

When neighborhood-based calculations are done at pixels along an image
boundary, they may call for pixel data that lies outside of the boundary.
Because this out-of-bounds data does not exist, an algorithm must supply it
according to some predetermined rules.  A rule for supplying out-of-bounds
pixel data is sometimes called a \emph{boundary condition}.
 
ITK neighborhood iterators automatically detect out-of-bounds dereferences and
return values according to boundary conditions.  The boundary condition type is
specified by the second, optional template parameter of the iterator.  By
default, neighborhood iterators use a Neumann condition where the first
derivative across the boundary is zero.  The Neumann rule simply returns the
closest in-bounds pixel value to the requested out-of-bounds location.  Several
other common boundary conditions can be found in the ITK toolkit.  They include
a wrap-around condition that returns the pixel value from the opposite side of
the data set, and is useful for periodic data such as Fourier transforms, and a
constant value condition that returns a set value $v$ for all out-of-bounds pixel
dereferences.  The constant value condition is equivalent to padding the image
with value $v$.

Bounds checking is a computationally expensive operation because it occurs each
time the iterator is incremented.  To increase effiency, a neighborhood
iterator will automatically disable bounds checking when it detects that it is
not necessary.  A user may also explicitly disable or enable bounds checking.
Most neighborhood based algorithms can minimize the need for bounds checking
through clever definition of iteration regions.  These techniques are explored
in section~\ref{sec:????????????????????????????????????????????}

\index{NeighborhoodIterators!}
\begin{itemize}
\item \textbf{\code{void NeedToUseBoundaryConditionOn()}} Explicitly turn
bounds checking on.  This method should be used with caution because
enabling bounds checking unnecessarily may result in a significant performance
decrease. In general you should allow the iterator to automatically determine
this setting.

\item \textbf{\code{void NeedToUseBoundaryConditionOff()}} Explicitly disable
bounds checking. This method should be used with caution because disabling
bounds checking when it is needed will result in out-of-bounds reads and
undefined results.
.
\item \textbf{\code{void OverrideBoundaryCondition(itk::BoundaryCondition *b}} 
Overrides the templated boundary condition, using boundary condition object
\code{b} instead. Object \code{b} should remain in scope until the iterator has
been destroyed.  This method can be used to change the boundary handling at
run-time.

\item \textbf{\code{void ResetBoundaryCondition()}} Discontinues use of any
run-time specified boundary condition and returns to using the condition
specified in the template argument.

\item \textbf{\code{void itk::SetPixel(unsigned int i, PixelType p, bool
status}} Sets the value at neighborhood array position \code{i} to value
\code{p}.  If the position \code{i} is out-of-bounds, \code{status} is set to
\code{false}, otherwise \code{status} is set to \code{true}.
\end{itemize}

%[Be sure to reference Section: Neighborhood Filters]

The following sections describe the two ITK neighborhood iterator classes,
\code{itk::NeighborhoodIterator} and \code{itk::ShapedNeighborhoodIterator}.
Each has a const and a non-const version.  The shaped iterator is a refinement
of the standard \code{itk::NeighborhoodIterator} that allows for an arbitrarily
(non-rectilinear) neighborhood.

\subsection{itk::NeighborhoodIterator}
\label{sec:itkNeighborhoodIterator}
The standard neighborhood iterators in ITK are the
\code{itk::ConstNeighborhoodIterator} and the 
\code{itk::NeighborhoodIterator}.  These two classes implement the complete API
described above and are the most commonly used neighborhood iterators.  This
section illustrates their use with several examples.  Refer to
section~\ref{sec:?????????????????????????????????????????????????} on
neighborhood filters for descriptions of algorithms in ITK that have been
written using the techniques described in this section.

\subsubsection{Basic neighborhood techniques: edge detection}
\input{NeighborhoodIterators1.tex}

\subsubsection{Convolution filtering: Sobel operator}
\input{Neighborhooditerators2.tex}

\subsubsection{Optimizing iteration speed}
\input{Neighborhooditerators3.tex}

\subsubsection{Separable convolution: Gaussian filtering}
\input{Neighborhooditerators4.tex}

\subsubsection{Slicing the neighborhood}
\input{Neighborhooditerators5.tex}

\subsubsection{Random access iteration}
\input{Neighborhooditerators6.tex}

%./Common/itkConstNeighborhoodIterator.h
%./Common/itkNeighborhoodIterator.h

% Example1: Edge detection using ``hand-coded'' Sobel operator
% Example2: Sobel edge detection using convolution filtering and Sobel operator
% Example3: Improving boundary condition efficiency
% Example4: gaussian filtering, separable convolution
% Example5: Slicing the neighborhood: gaussian filtering, separable convolution
% Example6: Advanced Neighborhood Techniques: local minima, local maxima

\subsection{itk::ShapedNeighborhoodIterator}
\label{sec:itkShapedNeighborhoodIterator}

This section describes a variation on the neighborhood iterator called a
\emph{shaped} neighborhood iterator.  A shaped neighborhood is created like
a bit mask, with different offsets in the rectilinear neighborhood of
the normal neighborhood iterator turned on or off to create a stencil.
Inactive positions (those not in the stencil) are not updated during iteration and
their values cannot be read or written.  The shaped iterator is implemented in
the class \doxygen{ShapedNeighborhoodIterator}, which is a subclass of
\doxygen{NeighborhoodIterator}.  A const version,
\doxygen{ConstShapedNeighborhoodIterator}, is also available.

Like a regular neighborhood iterator, a shaped neighborhood iterator must be
initialized with an ND radius object, but the radius of the neighborhood of a
shaped iterator only defines the set of \emph{possible} neighbors.  Any number
of possible neighbors can then be activated or deactivated.  The shaped
neighborhood iterator defines an API for activating neighbors.  When activated,
that neighbor location, defined relative to the center of the neighborhood, is
placed on the \emph{active list} and is then part of the stencil.  Neighbor
offsets can be added or removed from the stencil at any time.

\begin{itemize}

\item \textbf{\code{void ActivateOffset( itk::Offset &o)}} Include the offset
\code{o} in the stencil of active neighborhood positions.  Offsets are relative
to the neighborhood center.

\item \textbf{\code{void DeactivateOffset( itk::Offset &o)}} Remove the offset
\code{o} from the stencil of active neighborhood positions.  Offsets are
relative to the neighborhood center. 

\item \textbf{\code{void ClearActiveList()}} Deactivate all positions in the
iterator stencil by clearing the active list.

\item \textbf{\code{unsigned int GetActiveIndexListSize()}} Return the number
of pixel locations that are currently active in the shaped iterator stencil.

\end{itemize}

Because the neighborhood is less rigidly defined in the shaped iterator, the
set of pixel access methods is restricted.  Only the \code{GetPixel} and
\code{SetPixel} methods are available, and calling these methods on an inactive
neighborhood offset will return undefined results.

For the common case of traversing all pixel offsets in a neighborhood, the
shaped iterator class provides an iterator through the active offsets in its
stencil.   This \emph{stencil iterator} can be incremented or decremented and
defines \code{Get} and \code{Set} for reading and writing the values in the
neighborhood.

\begin{itemize}
\item \textbf{\code{ShapedNeighborhoodIterator::Iterator Begin()}} Return a
const or non-const iterator through the shaped iterator stencil that points to
the first valid location in the stencil.

\item \textbf{\code{ShapedNeighborhoodIterator::Iterator End()}} Return a
const or non-const iterator through the shaped iterator stencil that points
\emph{one position past} the last valid location in the stencil.
\end{itemize}

The functionality and interface of the shaped neighborhood iterator is best
described by example.  Let's use \doxygen{ShapedNeighborhoodIterator} to
implement some image morphology algorithms (see \cite{Gonzales1993},
\cite{Castleman1996}, et al.).  The two examples that follow implement erosion and
dilation.  When used in sequence, they perform opening and closing.

\subsubsection{Shaped neighborhoods: morphological operations}
\input{ShapedNeighborhoodIterators1.tex}
\input{ShapedNeighborhoodIterators2.tex}

%./Common/itkConstShapedNeighborhoodIterator.h
%./Common/itkShapedNeighborhoodIterator.h

\index{Iterators!neighborhood|)}

% ADD A SECTION WITH TIPS, SUGGESTIONS ON USING ITERATORS?  EXTENDING ITERATORS?
% USING ITERATORS FOR MULTITHREADING EXAMPLE?
\index{Iterators!image|)}
