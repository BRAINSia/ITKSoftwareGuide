

\chapter{Reading and Writing Images}
\label{sec:IO}

This chapter describes the toolkit architecture supporting reading and
writing of images to files. ITK does not enforce any particular file format,
instead, it provides a structure supporting a variety of formats that can
be easily extended by the user as new formats become available.

We begin the chapter with some simple examples of file I/O.

\section{Basic Example}
\label{sec:ImagReadWrite}
\input{ImageReadWrite.tex}

To better understand the IO architecture, please refer to Figures 
\ref{fig:ImageIOCollaborationDiagram}, 
\ref{fig:ImageIOFactoriesUseCases}, and
\ref{fig:ImageIOFactoriesClassDiagram}. 

\begin{figure}
\center
\includegraphics[width=\textwidth]{ImageIOCollaborationDiagram.eps}
\itkcaption[Collaboration diagram of the ImageIO classes]{Collaboration diagram
of the ImageIO classes.} \label{fig:ImageIOCollaborationDiagram}
\end{figure}

\begin{figure}
\center
\includegraphics[width=\textwidth]{ImageIOFactoriesUseCases.eps}
\itkcaption[Use cases of ImageIO factories] {Use cases of ImageIO factories.}
\label{fig:ImageIOFactoriesUseCases}
\end{figure}

\begin{figure}
\center
\includegraphics[width=\textwidth]{ImageIOFactoriesClassDiagram.eps}
\itkcaption[Class diagram of ImageIO factories] {Class diagram of the ImageIO
factories.}
\label{fig:ImageIOFactoriesClassDiagram}
\end{figure}

\section{Reading and Writing RGB Images}
\label{sec:RGBImagReadWrite}
\input{RGBImageReadWrite.tex}

\section{Reading, Casting and Writing Images}
\label{sec:ImagReadCastWrite}
\input{ImageReadCastWrite.tex}

\section{Extracting Regions}
\label{sec:ImagReadRegionOfInterestWrite}
\input{ImageReadRegionOfInterestWrite.tex}

\section{Extracting Slices}
\label{sec:ImagReadExtractWrite}
\input{ImageReadExtractWrite.tex}

\section{Reading and Writing Vector Images}
\label{sec:VectorImagReadWrite}

\input{CovariantVectorImageWrite.tex}

Let's now take the image that we just created and read it into another program.

\input{CovariantVectorImageRead.tex}


\section{Extracting Components from Vector Images}
\label{sec:VectorImageExtractComponent}
\input{CovariantVectorImageExtractComponent.tex}

\section{Reading Image Series}
\label{sec:ReadingImageSeries}
\input{ImageSeriesReadWrite.tex}
\input{RGBImageSeriesReadWrite.tex}


\section{Writing Image Series}
\label{sec:WritingImageSeries}
\input{ImageReadImageSeriesWrite.tex}

\section{Reading and Writing DICOM Images}
\label{sec:ReadingDicomImageSeries2}

% Small intro to DICOM file format

\subsection{Foreword}
ACR (the American College of Radiology) and NEMA (the National Electrical Manufacturers Association)
formed a joint committee to develop a Standard for Digital Imaging and COmmunications in Medicine (DICOM).
This DICOM Standard was developed according to the NEMA Procedures. This Standard is developed in liaison with other Standardization Organizations such as CEN TC251, JIRA including IEEE, HL7 and ANSI USA as reviewers.

With the introduction of computed tomography (CT) followed by other digital diagnostic imaging
modalities in the 1970's, and the increasing use of computers in clinical applications, the American
College of Radiology (ACR) and the National Electrical Manufacturers Association (NEMA) recognized
the emerging need for a standard method for transferring images and associated information between
devices manufactured by various vendors. These devices produce a variety of digital image formats.

DICOM is a comprehensive set of standards for handling, storing and transmitting information in medical
imaging. It includes both a file format definition as well as a network communication protocol.
DICOM was developed to enable integration of scanners, servers, workstations and network hardware from
multiple vendors into a picture archiving and communication system.

DICOM files consist of a header with standardized (See Insight/Utilities/gdcm/Dict/dicomV3.dic) as well 
as free-form fields and a body of image data. A single DICOM file can contain one or more frames, 
allowing storage of volumes or animations. Image data can be compressed using a variety of standards,
including JPEG, LZW and Run-length encoding (RLE).

The DICOM Standard is an evolving standard and it is maintained in accordance with the Procedures of
the DICOM Standards Committee. Proposals for enhancements are forthcoming from the DICOM
Committee member organizations based on input from users of the Standard. These proposals are
considered for inclusion in future editions of the Standard. A requirement in updating the Standard is to
maintain effective compatibility with previous editions. An entire newsgroup is dedicated to this: 
newsgroup://comp.protocols.dicom.

For a more detailed description of the DICOM standard see~\cite{DICOMStandard}.

\subsection{Reading and writing a 2D image}
\input{DicomImageReadWrite.tex}

\subsection{Reading a 2D DICOM Serie and writting a volume}
\input{DicomSeriesReadImageWrite2.tex}

\subsection{Reading a 2D DICOM serie and writting a 2D DICOM serie}
\input{DicomSeriesReadSeriesWrite.tex}



The following section describes the internals of the IO architecture provided
in the toolkit.

\section{Pluggable Factories}
\label{sec:ImageIOPluggableFactories}

The principle behind the input/output mechanism used in ITK is known as
\emph{pluggable-factories} \cite{Gamma1995}. This concept is illustrated in
the UML diagram in Figure~\ref{fig:ImageIOCollaborationDiagram}. From the
user's point of view the objects responsible for reading and writing files
are the \doxygen{ImageFileReader} and \doxygen{ImageFileWriter}
classes. These two classes, however, are not aware of the details involved in
reading or writing particular file formats like PNG or DICOM.  What they do
is to dispatch the user's requests to a set of specific classes that are
aware of the details of image file formats. These classes are the
\doxygen{ImageIO} classes. The ITK delegation mechanism enables users to
extend the number of supported file formats by just adding new classes to the
ImageIO hierarchy.

Each instance of ImageFileReader and ImageFileWriter has
a pointer to an ImageIO object. If this pointer is empty, it will
be impossible to read or write an image and the image file reader/writer must
determine which ImageIO class to use to perform IO operations.
This is done basically by passing the filename to a centralized class, the
\doxygen{ImageIOFactory} and asking it to identify any subclass of
ImageIO capable of reading or writing the user-specified file. This
is illustrated by the use cases on the right side of
Figure~\ref{fig:ImageIOFactoriesUseCases}.

Each class derived from ImageIO must provide an associated factory
class capable of producing an instance of the ImageIO class. For
example, for PNG files, there is a \doxygen{PNGImageIO} object that knows how
to read this image files and there is a \doxygen{PNGImageIOFactory} class
capable of constructing a PNGImageIO object and returning a pointer
to it.  Each time a new file format is added (i.e., a new ImageIO
subclass is created), a factory must be implemented as a derived class of the
ImageIOFactory class as illustrated in
Figure~\ref{fig:ImageIOFactoriesClassDiagram}.

For example, in order to read PNG files, a PNGImageIOFactory is
created and registered with the central ImageIOFactory
singleton\footnote{\emph{Singleton} means that there is only one instance of
this class in a particular application} class as illustrated in the left side
of Figure~\ref{fig:ImageIOFactoriesUseCases}. When the ImageFileReader asks
the ImageIOFactory for an ImageIO capable of reading the
file identified with \emph{filename} the ImageIOFactory will iterate over the
list of registered factories and will ask each one of them is they know how
to read the file. The factory that responds affirmatively will be used to
create the specific ImageIO instance that will be returned to the
ImageFileReader and used to perform the read operations.

In most cases the mechanism is transparent to the user who onlt interacts
with the ImageFileReader and ImageFileWriter. It is
possible, however, to explicitly select the type of ImageIO object
to use.  This is illustrated by the following example.


\section{Using ImageIO Classes Explicitly}
\label{sec:ImageReadExportVTK}
\input{ImageReadExportVTK.tex}



