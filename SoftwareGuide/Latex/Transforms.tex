
\def\tableconfiguration{ | p{4cm} | p{2.3cm} | p{4cm} | p{4cm} | }

\index{itk::Transform|textbf}

In the toolkit, \code{itk::Transform} objects encapsulate the mapping of points
and vectors from an input space to an output space.  If a transform is
invertible, back transform methods are also provided.  Currently, ITK provides
a variety of transforms from simple translation, rotation and scaling to
general affine and kernel transforms.  Note that, although in this section we
discuss transforms in the context of registration, transforms are general and
can be used for other applications. Some of the commonly used transforms will
be discussed in detail later. Let's introduce first the objects used in ITK for
for representing basic spatial concepts.

\subsection{Geometrical Representation}
\label{sec:GeometricalObjects}

\begin{figure}
\center
\includegraphics[width=14cm]{GeometricalObjects.eps}
\caption{Geometrical representation objects in ITK.}
\label{fig:GeometricalObjects}
\end{figure}
 
Insight implements a consistent geometric representation of the space. The
characteristics of classes involved in this representation are summarized in
the following table.

\index{itk::Point!Concept}
\index{itk::Vector!Concept}
\index{itk::CovariantVector!Concept}

\begin{center}
\begin{tabular}{ | p{4cm} | p{ 11cm } | }
\hline
\textbf{Class} &
\textbf{Geometrical concept} \\
\hline\hline
\code{itk::Point} & 
Position in space. In a $N$-Dimensional space it is represented by an array of
$N$ numbers associated with space coordinates. \\
\hline
\code{itk::Vector} & 
Relative position between two points. In a $N$-Dimensional space is represented
by an array of $N$-numbers each one associated with the distance along a
coordinate axis. Vectors do not have a position in space.\\
\hline
\code{itk::CovariantVector} & Orthogonal direction to a $(N-1)$-dimensional
manifold in space. For example, in $3D$ it corresponds to the vector orthogonal
to a surface. This is the appropriate class for representing gradients of
functions. Covariant vectors do not have a position in space.\\
\hline
\end{tabular}
\end{center}

Additional uses of the \code{Point}, \code{Vector} and \code{CovariantVector}
classes have been discussed in Chapter \ref{sec:DataRepresentation}.  Each one
of these classes behaves differently under spatial transformations. It is
henceforth quite important to keep their distinction clear. Figure
\ref{fig:GeometricalObjects} illustrates schematically the differences between
these concepts.


\index{itk::Transform!TransformPoint()}
\index{itk::Transform!TransformVector()}
\index{itk::Transform!TransformCovariantVector()}

\code{itk::Transform} classes provide different methods for mapping each one of
the basic space-representation objects.  Points, vectors and covariant vectors
are transformed using the methods \code{TransformPoint()},
\code{TransformVector()} and \code{TransformCovariantVector()} respectively.

\subsection{Transform General Properties}
\label{sec:TransformGeneralProperties}

\index{itk::Transform!SetParameters()}
Typically each transform class have several methods for setting its parameters.
For example, \code{Euler2DTransform} provide methods for separately setting the
offset, the angle, and the entire rotation matrix.  However, for use in the
registration framework, the parameters must also be represented by a flat
\code{Array<double>} to allow communication with generic optimizers. In the
case of \code{Euler2DTransform}, the transform is also defined by three
doubles: the first representing the angle and the last two the offset. The flat
array of parameters is defined using \code{SetParameters()}. A description of
the parameters and their ordering is documented in the following sections.
 
In the context of registration, the transform parameters define the search
space for optimizers. That is, the goal of the optimization is to find the set
of parameters defining a transform that results in the best possible value of
an image metric. The more parameters a transform has, the longer its
computational time will be when used in a registration method since the
dimension of the search space will be equal to the number of transform
parameters.

\index{itk::Transform!GetJacobian()}

Another requirement that the registration framework imposes on the transform
classes is the computation of their Jacobians. In general, metrics require the
knowledge of the Jacobian in order to compute the metric derivatives.  The
Jacobian is a matrix whose element are the partial derivatives of the output
point with respect to the array of parameters that defines the
transform\footnote{Note that the term \emph{Jacobian} is also commonly used for
the matrix representing the derivatives of output point coordinates with
respect to input point coordinates. Sometimes the term is loosely used to refer
to the determinant of such matrix.}:

\begin{equation}
J=\left[ \begin{array}{cccc}
\frac{\partial x_{1}}{\partial p_{1}} & 
\frac{\partial x_{1}}{\partial p_{2}} & 
\cdots  & \frac{\partial x_{1}}{\partial p_{m}}\\
\frac{\partial x_{2}}{\partial p_{1}} & 
\frac{\partial x_{2}}{\partial p_{2}} & 
\cdots  & \frac{\partial x_{2}}{\partial p_{m}}\\
\vdots  & \vdots  & \ddots  & \vdots \\
\frac{\partial x_{n}}{\partial p_{1}} & 
\frac{\partial x_{n}}{\partial p_{2}} & 
\cdots  & \frac{\partial x_{n}}{\partial p_{m}}
\end{array}\right]
\end{equation}

Where $\{p_i\}$ are the transform parameters and $\{x_i\}$ are the coordinates
of the output point.  Within this framework, the Jacobian is represented by a
\code{Array2D<double>} and is obtained from the transform by method
\code{GetJacobian()}. The Jacobian can be interpreted as a matrix that
indicates for a point in the input space how much its mapping on the output
space will change as a response to a small variation in one of the transform
parameters. Note the the values of the Jacobian matrix depend on the point in
the input space. So actually the Jacobian can be noted as $J(\bf{X})$. The use
of transform Jacobians allows to compute metric derivatives in a very efficient
way. When Jacobians are not available, metrics derivatives have to be computed
using finite difference at a price of $2M$ evaluations of the metric value,
where $M$ is the number of transform parameters.

The following sections describe the main characteristics of the transform
classes available in ITK.

\subsection{Identity Transform}
\label{sec:IdentityTransform}
\index{itk::IdentityTransform|textbf}

\begin{center}
\begin{tabular}{\tableconfiguration}
\hline
\textbf{Behavior} &
\textbf{Number of parameters} &
\textbf{Parameter Ordering} &
\textbf{Restrictions} \\
\hline\hline
Maps every point to itself, every vector to itself and every covariant vector to itself.  & 
0 &
  &  
Only defined when the input and output space has the same number of dimensions. \\
\hline
\end{tabular}
\end{center}

The identity transform is mainly used for debugging purposes. It is a mechanism
to provide a transform to methods that require it but yet have the certainty
that the transform will have no effect whatsoever in the outcome of the
process. It is just a \code{NULL} operation.


\subsection{Translation Transform}
\label{sec:TranslationTransform}
\index{itk::TranslationTransform|textbf}

\begin{center}
\begin{tabular}{\tableconfiguration}
\hline
\textbf{Behavior} &
\textbf{Number of parameters} &
\textbf{Parameter Ordering} &
\textbf{Restrictions} \\
\hline\hline
Represents a simple translation of points in the input space
and has no effect on vectors or covariant vectors. &
Same as the input space dimension. &
The $i$-th parameter represents the translation in the $i$-th dimension. &
Only defined when the input and output space has the same number of dimensions. \\
\hline
\end{tabular}
\end{center}


The translation transform is probably the simplest yet useful transformation.
It maps all points in space by adding a constant values to their coordinates.
Vector and covariant vectors remain unchanged under this transformation since
they are not associated to a position in space. Translation is the best
transform to start a registration method. Before attempting to solve for
rotations or scaling  it is important to overlap the anatomical objects in both
images as much as possible. This is done by resolving the translational
misalignment between the images. Translations also have the advantages of
being fast to compute and having parameters that are easy to interpret.



\subsection{Scale Transform}
\label{sec:ScaleTransform}
\index{itk::ScaleTransform|textbf}

\begin{center}
\begin{tabular}{\tableconfiguration}
\hline
\textbf{Behavior} &
\textbf{Number of parameters} &
\textbf{Parameter Ordering} &
\textbf{Restrictions} \\
\hline\hline
Points are transformed by multiplying each one of their coordinates by the
corresponding scale factor for the dimension.  Vector are transformed as
points.  Covariant vectors are transformed by \emph{dividing} their components
by the scale factor of the corresponding dimension.  &
Same as the input space dimension. &
The $i$-th parameter represents the scaling in the $i$-th dimension. &
Only defined when the input and output space has the same number of dimensions. \\
\hline
\end{tabular}
\end{center}

This transform represents a simple scaling of the vector space.  Different
scaling factors can be applied along each dimension. Points are transformed by
multiplying each one of their coordinates by the  corresponding scale factor
for the dimension.  Vector are transformed in the same way as points.
Covariant vectors, on the other hand, are transformed differently since
anisotropic scaling does not preserve angles. Covariant vectors are transformed
by \emph{dividing} their components by the scale factor of the corresponding
dimension. In this way, if a covariant vector was orthogonal to a vector, this
orthogonality will be preserved after the transformation. The following
equations summarize the effect of the transform on the basic geometric objects.

\begin{equation}
\begin{array}{lccccccc}
\mbox{Point }          & \bf{P'} &  =  & T(\bf{P})  & : & \bf{P'}_i &  = & \bf{P}_i \cdot S_i \\
\mbox{Vector}          & \bf{V'} &  =  & T(\bf{V})  & : & \bf{V'}_i &  = & \bf{V}_i \cdot S_i \\
\mbox{CovariantVector} & \bf{C'} &  =  & T(\bf{C})  & : & \bf{C'}_i &  = & \bf{C}_i /     S_i \\
\end{array}
\end{equation}

where $\bf{P}_i$, $\bf{V}_i$ and $\bf{C}_i$ are the point, vector and covariant
vector $i$-th components while $S_i$ is the scaling factor along dimension $i$.
The following equation illustrates the effect of the scaling transform on a
$3D$ point.

\begin{equation}
\left[ 
\begin{array}{c}
x' \\
y' \\
z' \\
\end{array}
\right]
=
\left[ 
\begin{array}{ccc}
S_1 &  0  &  0  \\
 0  & S_2 &  0  \\
 0  &  0  & S_3 \\
\end{array}
\right]
\cdot
\left[ 
\begin{array}{c}
x  \\
y  \\
z  \\
\end{array}
\right]
\end{equation}


Scaling is an apparently simple transformation but actually there are a number of
issues to keep in mind when it is used with different factors
along every dimension. It has subtle effects in things like computing image
derivatives. Since derivatives are represented by covariant vectors their
values are modified in a particular way by scaling transforms.

One of the difficulties in managing scaling transforms in a registration
process is that typical optimizers manage the parameter space as a vector space
in which addition is the basic operation. Scaling would be treated more
naturally in the frame of a logarithmic space where additions will results in
regular multiplicative increments of the scale. Optimizers in the family of
gradient-descent will have trouble finding a step-length appropriate for
updating a scale since the effect of an additive increment on a scale factor
will diminish as the factor grows. In other words, a scale factor variation of
$(1.0+ \epsilon)$ is quite different from a scale variation of $(5.0+\epsilon)$.

Registrations involving scale transforms require careful monitoring of the
optimizer parameters in order to keep it running at an interesting yet stable
pace. Note that some of the transforms discussed in following sections, for
example the \code{AffineTransform}, have hidden scaling parameters and are henceforth
subject to the same vulnerabilities of the \code{ScaleTransform}.

In cases involving misalignments with simultaneous translation, rotation
and scaling components it may be desirable to solve for these components
independently.


\subsection{Euler2DTransform}
\label{sec:Euler2DTransform}
\index{itk::Euler2DTransform|textbf}

\begin{center}
\begin{tabular}{\tableconfiguration}
\hline
\textbf{Behavior} &
\textbf{Number of parameters} &
\textbf{Parameter Ordering} &
\textbf{Restrictions} \\
\hline\hline
Represents a 2D rotation and a 2D translation. Note that the translation
component has no effect on the transformation of vectors and covariant vectors. &
3 &
The first parameter is the angle in radians and the last two parameters
are the translation in each dimension. &
Only defined for two-dimensional input and output spaces. \\
\hline
\end{tabular}
\end{center}

Euler2DTransform implements a rigid transformation in $2D$. It is composed of a
plane rotation and a two-dimensional translation. The rotation is applied
first, followed by the translation. The following equation illustrates the
effect of this transform in a $2D$ point.


\begin{equation}
\left[ 
\begin{array}{c}
x' \\
y' \\
\end{array}
\right]
=
\left[ 
\begin{array}{cc}
\cos{\theta} & -\sin{\theta} \\
\sin{\theta} &  \cos{\theta} \\
\end{array}
\right]
\cdot
\left[ 
\begin{array}{c}
x  \\
y  \\
\end{array}
\right]
+ 
\left[ 
\begin{array}{c}
T_x  \\
T_y  \\
\end{array}
\right]
\end{equation}

where $\theta$ is the rotation angle and $(T_x,T_y)$ are the components of the
translation.

The difficult aspect of this transformation
is the fact that translations and rotations do not form a vector space and can
not be managed as linear independent parameters. Typical optimizers make the
loose assumption of managing the parameters as a vector space and rely on the
step-length to be small enough for this assumption to hold approximately.

In addition to the non-linearity of the parameter space, the most common
difficulty of this transform is the difference in units used for rotations and
translations. Rotations are measured in radians, hence their values are in the
range $[-\pi,\pi]$. Translations are measured in millimeters and their actual
values vary depending on the image modality being considered. In practice,
translations have values on the order of $10$ to $100$. This scale difference
between rotation and translation parameters is undesirable for gradient-descent
optimizers because they deviate the trajectories of descent making optimization
slower and more unstable. In order to compensate for these differences, ITK
optimizers accept an array of scale values that are used to normalize the
parameter space.

Registrations involving angles and translations should take advantage of the
scale normalization functionality in order to get the best performance out of
the optimizers.


\subsection{CenteredRigid2DTransform}
\label{sec:CenteredRigid2DTransform}
\index{itk::CenteredRigid2DTransform|textbf}

\begin{center}
\begin{tabular}{\tableconfiguration}
\hline
\textbf{Behavior} &
\textbf{Number of parameters} &
\textbf{Parameter Ordering} &
\textbf{Restrictions} \\
\hline\hline
Represents a 2D rotation around an arbitrary center followed by a 2D translation.&
5 &
The first parameter is the angle in radians. Second and third are the center of
rotation coordinates and the last two parameters are the translation in each
dimension. & 
Only defined for two-dimensional input and output spaces. \\
\hline
\end{tabular}
\end{center}

CenteredRigid2DTransform implements a rigid transformation in $2D$. The main
difference between this transform and the \code{Euler2DTransform} is that here
we can specify an arbitrary center of rotation, while the
\code{Euler2DTransform} always use the origin of the coordinate system as
rotation center. This distintion is quite important in image registration since
ITK images usually have their origin in the corner of the image rather than the
middle.  Rotational miss-registrations however usually exist as rotations
around the center of the image, or at least as rotations around a point in the
middle of the anatomical structure captured by the image. Using gradient
descent optimizers, it is almost imposible to solve non-origin rotations using
origin rotations since the deep basin of the real solution is across a high
ridge in the topography of the cost function.

In practice this transform is used as follows: the user supplies the center of
rotation in the input space, the angle of rotation and a translation to be
applied after the rotation.

With these parameters the transforms initialize a rotational matrix and a
transform that performs the equivalent tasks of: Translating the center of
rotation to the origin of coordinates, rotating by the specified angle,
translating back to the center of rotation and finally translate by the
especified translation.

As the \code{Euler2DTransform} this transform suffers from the difference in
units used for rotations and translations. Rotations are measured in radians,
hence their values are in the range $[-\pi,\pi]$. The center of rotation and
the translations are measured in millimeters and their actual values vary
depending on the image modality being considered.  Registrations involving
angles and translations should take advantage of the scale normalization
functionality in order to get the best performance out of
the optimizers.

The following equation illustrates the effect of the transform in an input
point $(x,y)$ that maps to the output point $(x',y')$.

\begin{equation}
\left[ 
\begin{array}{c}
x' \\
y' \\
\end{array}
\right]
=
\left[ 
\begin{array}{cc}
\cos{\theta} & -\sin{\theta} \\
\sin{\theta} &  \cos{\theta} \\
\end{array}
\right]
\cdot
\left[ 
\begin{array}{c}
x - C_x \\
y - C_y \\
\end{array}
\right]
+ 
\left[ 
\begin{array}{c}
T_x + C_x \\
T_y + C_y \\
\end{array}
\right]
\end{equation}

where $\theta$ is the rotation angle, $(C_x,C_y)$ are the coordinates of the
rotation center and $(T_x,T_y)$ are the components of the translation. Note
that the center coordinates are subtracted before the rotation and added back
after the rotation.

\subsection{Similarity2DTransform}
\label{sec:Similarity2DTransform}
\index{itk::Similarity2DTransform|textbf}

\begin{center}
\begin{tabular}{\tableconfiguration}
\hline
\textbf{Behavior} &
\textbf{Number of parameters} &
\textbf{Parameter Ordering} &
\textbf{Restrictions} \\
\hline\hline
Represents a 2D rotation, homogeneous scaling and a 2D translation. Note that
the translation component has no effect on the transformation of vectors and
covariant vectors. & 
4 &
The first parameter is the angle in radian, the second the scaling factor for
all dimensions and the last two parameters are the translation in each
dimension. & 
Only defined for two-dimensional input and output spaces. \\
\hline
\end{tabular}
\end{center}

A similarity transform preserves angles. It can be seen as a rigid transform
plus an isotropic scaling factor. In its $2D$ implementation, the four
parameters of this transformation combine the characteristics of the
\code{Scale} and \code{Euler2DTransform} concerning the non-linearity of the
parameter space and the non-uniformity of the measure units. Gradient-descent
optimizers should be used with caution on such parameter spaces since the
notion of gradient direction and step-length are ill-defined.

A possible approach for supervising optimization in the parameter space of this
transform is to dynamically control the array of scales passed to the
optimizer. The effect produced by the parameters scaling  can be used to steer
the walk on the parameter space by giving preference to some of the parameters
over others. For example, perform some iterations updating only the rotation
angle then balance the array of scale factor in the optimizer and perform
another set of iterations updating only translations.


\subsection{QuaternionRigidTransform}
\label{sec:QuaternionRigidTransform}
\index{itk::QuaternionRigidTransform|textbf}

\begin{center}
\begin{tabular}{\tableconfiguration}
\hline
\textbf{Behavior} &
\textbf{Number of parameters} &
\textbf{Parameter Ordering} &
\textbf{Restrictions} \\
\hline\hline
Represents a 3D rotation and a 3D translation. The rotation is specified as a
quaternion, defined by a set of four numbers $\bf{q}$.  The relationship
between quaternion and rotation about vector $\bf{n}$ by angle $\theta$ is as
follows: \[ \bf{q} = (\bf{n}\sin(\theta/2), \cos(\theta/2))\] Note that if the
quaternion is not of unit length, scaling will also result. &
7 &
The first four parameters defines the quaternion and the last three parameters
the translation in each dimension. &
Only defined for three-dimensional input and output spaces. \\
\hline
\end{tabular}
\end{center}

This class implements a rigid transformation in $3D$ space. The rotational part
of the transform is represented using a quaternion while the translation is
represented with a vector. Quaternions components do not form a vector space
and hence raise the same concerns of the \code{Similarity2DTransform} when used
with gradient-descent optimizers.

As a solution, the \code{itk::QuaternionRigidTransformGradientDescentOptimizer}
was introduced in the toolkit.  This specialized optimizer implements a
variation of a gradient-descent algorithm adapted for a quaternion space.  This
class makes sure that after advancing in any direction on the parameter space
the resulting new set of transform parameters are mapped back to the permissible
set of parameters. In practice this comes down to normalizing the newly computed
quaternion to make sure that the transformation remains rigid and no scaling is
applied. 




\subsection{VersorTransform}
\label{sec:VersorTransform}
\index{itk::VersorTransform|textbf}
\index{itk::VersorTransformOptimizer|textbf}
\index{itk::Versor!Definition|textbf}

\begin{center}
\begin{tabular}{\tableconfiguration}
\hline
\textbf{Behavior} &
\textbf{Number of parameters} &
\textbf{Parameter Ordering} &
\textbf{Restrictions} \\
\hline\hline
Represents a 3D rotation. The rotation is specified by a
versor or unit quaternion. &
3 &
The three parameters define the versor.&
Only defined for three-dimensional input and output spaces. \\
\hline
\end{tabular}
\end{center}


A \emph{Versor} is by definition the rotational part of a quaternion. It can
also be defined as a \emph{unit-quaternion} \cite{Hamilton1866,Joly1905}.
Versors only have three independent components since they are restricted to
reside in the space of unit-quaternions. The implementation of Versors in the
toolkit uses a set of three numbers.  These three numbers correspond to the
first three components of a quaternion.  The fourth component of the quaternion
is computed internally such that the quaternion is of unit length.

This transform represents exclusively rotations in 3D. It is intended to solve
rapidly the rotational component of a more generic misalignment.  It is
desirable to remove first any translation in order to superimpose the gravity
centers of the images. The efficiency of this transform comes from using a
parameter space of reduced dimensionality. Versors are the best possible
representation for rotations in $3D$ space. Sequences of versors allow the
creation of smooth rotational trajectories and for this reason they behave stably
under optimization methods.

The space formed by versor parameters is not a vector space. Standard
gradient-descent algorithms are not appropriate for exploring this parameter
space. An optimizer specialized for the versor space is available in the
toolkit under the name of \code{itk::VersorTransformOptimizer}. This optimizer
implements Versor derivatives as defined by original Hamilton
\cite{Hamilton1866}.

Note that the coordinate systems in ITK are determined by the settings of the
\code{Origin} defined in the image class. Rotations will be applied in this
coordinate space, not with respect to the center of the image as can be naively
expected.



\subsection{VersorRigid3DTransform}
\label{sec:VersorRigid3DTransform}
\index{itk::VersorRigid3DTransform|textbf}

\begin{center}
\begin{tabular}{\tableconfiguration}
\hline
\textbf{Behavior} &
\textbf{Number of parameters} &
\textbf{Parameter Ordering} &
\textbf{Restrictions} \\
\hline\hline
Represents a 3D rotation and a 3D translation. The rotation is specified by a
versor or unit quaternion, while the translation is represented by a vector. &
6 &
The first three parameters define the versor and the last three parameters the
translation in each dimension. &
Only defined for three-dimensional input and output spaces. \\
\hline
\end{tabular}
\end{center}

This transform is a close variant of the \code{QuaternionRigidTransform}. It
can be seen as a the \code{VersorTransform} plus a translation defined by a
vector. It general terms it implements a rigid transform in $3D$.  The
advantage of this class with respect to the \code{QuaternionRigidTransform} is
that it exposes only 6 parameters, three for the versor components and three
for the translational components. This makes the search space for the optimizer
to be reduced to dimension 6 instead of the dimension 7 used by
\code{QuaternionRigidTransform}.



\subsection{AffineTransform}
\label{sec:AffineTransform}
\index{itk::AffineTransform|textbf}

\begin{center}
\begin{tabular}{\tableconfiguration}
\hline
\textbf{Behavior} &
\textbf{Number of parameters} &
\textbf{Parameter Ordering} &
\textbf{Restrictions} \\
\hline\hline
Represents an affine transform composed of rotation, scaling, shearing and
translation. The transform is specified by a $N \times N$ matrix and a $N
\times 1$ vector where $N$ is space dimension. &
$(N+1) \times N$ &
The first $N \times N$ parameters defines the matrix in column-major order
(where the column index varies the fastest).  The last $N$ parameters defines
the translate for each dimension. &
Only defined when the input and output space have the same dimension. \\
\hline
\end{tabular}
\end{center}


The \code{AffineTransform} is one of the most popular transformations in image
registration. Its main advantage comes from the fact of being represented as a
linear transformation. The set of its coefficients can actually be represented
in a vector space of dimensions $(N+1) \times N$. This makes it possible for
optimizers to be used appropriately on this search space. However the high
dimensionality of the search space implies also a high computational cost during the
computation of cost-function derivatives. The best compromise in the reduction
of this computational time is to use the transform Jacobian in combination with
the image gradient for computing the cost-function derivatives.

The coefficients on the $N \times N$ matrix can represent rotations,
anisotropic scaling and shearing. These coefficients are usually of a very
different dynamic range compared to the translation coefficients. Coefficients in the 
matrix tend to be in the range $[-1:1]$ but are not restricted to this interval.
Translation coefficients on the other hand can be on the order of $10$ to $100$ and
are basically related to the image size and pixel spacing.

This difference in scale makes it necessary again to take advantage of the
functionality offered by optimizer for rescaling the parameter space. This is
particularly relevant for optimizers based on gradient-descent approaches.

A registration based on the affine transform may be more effective when applied
after simpler transformations have been used to remove the major components of
misalignment. Otherwise it will incur in an overwhelming computational
cost. For example, using an affine transform, the first set of optimization
iterations would typically be focused on removing large translations. This task
could rather be accomplished by a translation transform in a parameter space of
size $N$ instead of the $(N+1) \times N$ associated with the affine transform.

Tracking the evolution of a registration process that uses
\code{AffineTransforms} can be a challenging task since it is difficult to
represent the coefficients in a meaningful way.  The simple print out of the
transform coefficients may not offer a clear picture of the current behavior
and trend of the optimization.  An ergonomic implementation could rather use
the affine transform to deform the rendering of a wire-frame cube in a 3D
visualization display.


