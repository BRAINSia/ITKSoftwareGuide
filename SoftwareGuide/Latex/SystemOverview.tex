\chapter{System Overview}
\label{chapter:SystemOverview}

The purpose of this chapter is to provide you with an overview of the
\emph{Insight Toolkit} system. We recommend that you read this chapter to
gain an appreciation for the breadth and area of application of ITK.
(Note: this chapter is not yet completed at this time.)

\section{System Organization}
\label{sec:SystemOrganization}

The Insight Toolkit consists of several subsystems. A brief
description of these subsystems follows. Later sections in this chapter---and
in some cases addtional chapters---cover these concepts in more detail. 

\begin{description}
	\item[Essential System Objects.] Like any software system, ITK is
        built around some core design features. Some of the more important
        features include smart pointers for memory management, object factories
        for adaptable object instantiation, event management using the 
        command/observer design paradigm, and multithreading support.

	\item[Data Representation and Access.]  Two principle classes are
        used to represent data: the Image and Mesh classes. In addition,
        various types of iterators and containers are used to hold and
        traverse the data. Other important but less popular classes are
        also used to represent data such as histograms and BLOX images.

	\item[Numerics] ITK uses VXL's VNL numerics libraries. These are
        easy-to-use C++ wrappers around the Netlib Fortran numerical 
        analysis routines (\url{http://www.netlib.org}).

	\item[Data Processing Pipeline.]  The data representation classes are
        operated on by \emph{filters} that in turn may be organized into data
        flow pipelines. These pipelines maintain state and therefore execute
        only when necessary, support multi-threading, and are streaming
        capable (i.e., can operate on pieces of data to minimize the
        memory footprint).

        \item[IO Framework.] Associated with the data processing pipeline are
        sources, i.e., filters that initiate the pipeline, and mappers,
        filters that terminate the pipeline. A common type of
        sources are readers, used to input data, and writers, used to
        output data from the pipeline. ITK uses a flexible object factory
        mechanism supporting a variety of file formats.

	\item[Registration Framework.] A flexible framework for registration
        supports four different types of registration: image registration,
        multiresolution registration, PDE based registration, and FEM (finite-
        element, i.e., deformable) registration.

	\item[FEM Framework.] ITK includes a subsystem for solving general
        FEM problems, in particular non-rigid registration. The FEM package
        includes mesh definition (nodes and elements), loads, and boundary
        conditions.

	\item[Spatial Objects.] A hierarchy of classes for shape
        representation.  These classes are intended to support modeling of
        anatomical structures. Using a common basic interface, the spatial
        objects are capable of representing regions of space in a variety of
        different ways. For example: mesh structures, image masks, and
        implicit equations.  Spatial objects are the natural data structure
        for communications the results of segmentation methods and for
        introducing anatomical priors in both segmentation and registration
        methods.

	\item[Level Set Framework.] The level set framework is a set of
        classes for creating filters to solve partial differential equations
        on images using an iterative, finite difference update scheme. The
        level set framework consists of finite difference solvers including a
        sparse level set solver, a generic level set segmentation filter, and
        several specific subclasses including threshold, Canny, and Laplacian
        based methods.

	\item[Wrapping.] ITK uses a unique, powerful system for producing
        interfaces (i.e., ``wrappers'') to interpreted languages such as Tcl
        and Python. The CABLE system is capable of wrapping C++ code of
        arbitrary complexity because it uses a compiler to parse the code.
        The parsed code is in turn represented using XML which is then
        used to build the language interfaces.

	\item[Auxiliary / Utilities] Several auxiliary subsystems are 
        available to supplement other classes in the system. For example,
        calculators are classes that perform specialized operations in
        support of filters (e.g., MeanCalculator computes the mean of a
        sample). Other utilities include a partial DICOM parser, MetaIO file
        support, png, zlib, FLTK / Qt image viewers, and interfaces to the
        Visualization Toolkit (VTK) system.
        
\end{description}


\section{Essential System Objects}
\label{sec:EssentialSystemObjects}

This section describes some of the core objects and implementation constructs
found in ITK.

\subsection{Include Files and Class Definitions}
\label{sec:IncludeFiles}

In ITK classes are defined by a maximum of two files: a header \code{.h} file
and an implementation file---\code{.cxx} if a non-templated class, and a
\code{.txx} if a templated class. The header files contains documentation that
is used by the Doxygen documentation systen to produce the HTML manual pages.

In addition to class headers, there are a few other important header files.
\begin{description}
        \item[\code{itkMacro.h}] is found in the \code{Code/Common} directory
        and defines standard system-wide macros (such as \code{Set/Get},
        constants, and other parameters.

        \item[\code{itkNumericTraits.h}] is found in the \code{Code/Common} 
        directory and defines numeric characteristics for native types such
        as its maximum and minimum possible values.

        \item[\code{itkWin32Header.h}] is found in the \code{Code/Common} 
        and is used to define operating system parameters to control
        the compilatilation process.
\end{description}

\subsection{Smart Pointers}
\label{sec:SmartPointers}

By their nature object-oriented systems represent and operate on data through
a variety of object types, or classes. When a particular class is
instantiated to produce an instance of that class, memory allocation occurs
so that the instance can store data attribute values and method pointers
(i.e., the vtable). This object may then be referenced by other classes or
data structures during normal operation of the program. At some
point---certainly by the time the program is exiting---all references to that
instance disappear. At this point, the instance must be deleted to recover
the valuable memory resource that the instance no longer requires. This process
is known as memory management.

In ITK, memory management is implemented through reference counting. This
compares to another popular approach---garbage collection---used by many
systems including Java. In reference counting, a count of the number of
references to each instance is kept. When the reference goes to zero, the
object destroys itself. In garbage collection, a background process sweeps
the system identifying instances no longer referenced in the system and
deletes them. The problem with garbage collection is that the actual point in
time at which memory is deleted is variable. This is unacceptable when an
object size may be gigantic (think of a large 3D volume gigabytes in
size). Reference counting deletes memory immediately.

Reference counting is implemented as follows. Instances have a
\code{Register()} method invoked on them by a class that uses the
instance. The \code{Register()} method increments the instances' reference
count. When the reference to the instance disappears, a \code{Delete()}
method is invoked on the instance---this is equivalent to an
\code{UnRegister()} method that decrements the reference count. When the
reference count returns to zero, the instance is destroyed.

This protocol is greatly simplified by using a helper class called a
\code{SmartPointer}. The smart pointer acts like a regular pointer 
(e.g. supports operators \code{->} and \code{*}) but automagically
performs a \code{Register()} when referring to an instance, and an
\code{UnRegister()} when it no longer points to the instance.  Unlike
most other instances in ITK, \code{SmartPointer}s can be allocated
on the program stack, and are automatically deleted when the scope in
which the \code{SmartPointer} was created is closed. As a result, you should
\emph{rarely if ever call Register() or Delete()} in ITK. For example:

\begin{verbatim}
  MyRegistrationFunction()
    { <----- Start of scope

    // here an interpolator is created and associated to the
    // SmartPointer "interp".
    InterpolatorType::Pointer interp = InterpolatorType::New();

    } <------ End of scope
\end{verbatim}


At the end of scope, the \code{SmartPointer} \code{interp} is destroyed, the
reference count of the actual interpolator object is decremented, and if it
reaches zero, then the interpolator is also destroyed.

%	multithreading, smart pointers, object factories, system includes,
%	command/observers/events
%

%\section{Data Representation and Access}
%\label{sec:DataRepresentationAndAccess}
%
%	mesh, image, iterators, various containers
%
\section{Numerics}
\label{sec:Numerics}

ITK uses the \code{VNL} numerics library and provides extra functionality
beyond \code{VNL} including interface classes to ITK proper.  The numerics
library, \code{VNL} is intended to provide an environment for numerical
programming which combines the ease of use of packages like Mathematica and
Matlab with the speed of C and the elegance of C++. It provides a C++
interface to the high-quality Fortran routines made available in the public
domain by numerical analysis researchers.

The VNL numerics library includes classes for 
\begin{description}
        \item[Matrices and vectors.] Standard matrix and vector support
        and operations on these types.

        \item[Specialized matrix and vector classes.] Several special matrix
        and vector class with special numerical properties are
        available. Class \code{vnl\_diagonal\_matrix} provides a fast and
        convenient diagonal matrix, while fixed size matrices and vectors
        allow "fast-as-C" computations (see \code{vnl\_matrix\_fixed<T,n,m>} 
        and example subclasses \code{vnl\_double\_3x3} and 
        \code{vnl\_double\_3}).

        \item[Matrix decompositions.] Classes \code{vnl\_svd<T>}, 
        \code{vnl\_symmetric\_eigensystem<T>}, and 
        \code{vnl\_generalized\_eigensystem}. 

        \item[Real polynomials.] Class \code{vnl\_real\_polynomial} stores 
        the coefficients of a real polynomial, and provides methods of 
        evaluation of the polynomial at any x, while class 
        \code{vnl\_rpoly\_roots} provides a root finder. 

        \item[Optimization.] Classes \code{vnl\_levenberg\_marquardt},
        \code{vnl\_amoeba}, \code{vnl\_lbfgs},
        \code{vnl\_conjugate\_gradient} allow optimization of user-supplied
        functions either with or without user-supplied derivatives.

        \item[Standardized functions and constants.] Class \code{vnl\_math}
        defines constants (pi, e, eps...) and simple functions (sqr, abs,
        rnd...). Class \code{numeric\_limits} is from the ISO standard
        document, and provides a way to access basic limits of a
        type. E.g. \code{numeric\_limits<short>::max()} returns the maximum
        value of a short.
\end{description}

Most VNL routines are implemented as wrappers around the high-quality Fortran
routines which have been developed by the numerical analysis community over
the last forty years and placed in the public domain. The central repository
for these programs is the "netlib" server \url{http://www.netlib.org/}. The
National Institute of Standards and Technology (NIST) provides an excellent
search interface to this repository in its Guide to Available Mathematical
Software (GAMS) at \url{http://gams.nist.gov}, both as a decision tree and a
text search.

ITK provides additional numerics functionality. A suite of optimizers, that
use \code{VNL} under the hood and integrate with the registration framework
are available. A large collection of statistics functions---not available from
\code{VNL}---are also provided in the \code{Insight/Numerics/Statistics}
directory. In addition, a complete finite element (FEM) package is available,
primarily to support the deformable registration in ITK.

%\section{Data Processing Pipeline}
%\label{sec:DataProcessingPipeline}
%
%filters, mappers, update
%
%\section{Registration Framework}
%\label{sec:RegistrationFramework}
%
%blah blah
%
%\section{FEM Framework}
%\label{sec:FEMFramework}
%
%blah blah
%
\section{Spatial Objects}
\label{sec:SpatialObjects}
%
The ITK spatial object framework supports the philosophy that the task of
image segmentation and registration is actually the task of object
processing. The image is but one medium for representing objects of interest,
and much processing and data analysis can and should occur at the object
level and not based on the medium used to represent the object.

ITK spatial objects provide a common interface for accessing the physical
location and geometric properties of and the relationship between objects in
a scene that is independent of the form used to represent those objects. That
is, the internal representation maintained by a spatial object may be a list
of points internal to an object, the surface mesh of the object, a continuous
or parametric representation of the object's internal points or surfaces, and
so forth.

The capabilities provided by the spatial objects framework supports their use
in object segmentation, registration, surface/volume rendering, and other
display and analysis functions. The spatial object framework extends the
concept of a "scene graph" that is common to computer rendering packages so
as to support these new functions. With the spatial objects framework you
can:
\begin{enumerate}

        \item Specify a spatial object's parent and children objects.  In
        this way, a liver may contain vessels and those vessels can be
        organized in a tree structure.

        \item Query if a physical point is inside of an object or
        (optionally) any of its children.

        \item Request the value and derivatives at a physical point as
        specified by an object or (optionally) its children.

        \item Specify the coordinate transformation that maps a parent
        object's coordinate system into a child object's coordinate system.

        \item Compute the bounding box of a spatial object and (optionally)
        its children.

        \item Query the resolution at which the object was originally
        computed.  For example, you can query the resolution (i.e., voxel
        spacing) of the image used to generate a particular instance of a
        \code{BlobSpatialObject}.
\end{enumerate}

Currently implemented types of spatial objects include: Blob, Ellipse, Group,
Image, Line, Surface, and Tube.  The \code{itk::Scene} object is used to hold
a list of spatial objects that may in-turn have children.  Each spatial
object can be assigned a color property.  Each spatial object type has its
own capabilities. For example, \code{TubeSpatialObject}s indicate to what
point on their parent tube they connect.

There are a limited number of spatial objects and their methods in ITK, but
their number is growing and their potential is huge. Using the nominal
spatial object capabilities methods, such as marching cubes or mutual
information registration, can be applied to objects regardless of their
internal representation. By having a common API, the same method can be used
to register a parametric representation of a heart with an individual's CT
data or to register two hand segmentations of a liver.

%blah blah
%
%\section{Level Set Framework}
%\label{sec:LevelSetFramework}
%
%blah blah
%
%\section{Wrapping}
%\label{sec:Wrapping}
%
%blah blah
%
%\section{Auxiliary \& Utilities}
%\label{sec:Auxiliary}
%\label{sec:Utilities}
%
%calculators and classes supporting the data processing pipeline;
%utilities such as GUI interface tools
